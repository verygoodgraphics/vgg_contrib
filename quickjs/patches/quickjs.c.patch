--- original/quickjs/quickjs.c	2022-11-18 18:50:21.000000000 +0800
+++ upstream/quickjs/quickjs.c	2022-11-27 09:15:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
  * QuickJS Javascript Engine
- * 
+ *
  * Copyright (c) 2017-2021 Fabrice Bellard
  * Copyright (c) 2017-2021 Charlie Gordon
  *
@@ -28,16 +28,18 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/time.h>
 #include <time.h>
 #include <fenv.h>
 #include <math.h>
 #if defined(__APPLE__)
 #include <malloc/malloc.h>
+#include <sys/time.h>
 #elif defined(__linux__)
 #include <malloc.h>
+#include <sys/time.h>
 #elif defined(__FreeBSD__)
 #include <malloc_np.h>
+#include <sys/time.h>
 #endif
 
 #include "cutils.h"
@@ -50,7 +52,7 @@
 
 #define OPTIMIZE         1
 #define SHORT_OPCODES    1
-#if defined(EMSCRIPTEN)
+#if defined(EMSCRIPTEN) || defined(_MSC_VER)
 #define DIRECT_DISPATCH  0
 #else
 #define DIRECT_DISPATCH  1
@@ -69,11 +71,11 @@
 
 /* define to include Atomics.* operations which depend on the OS
    threads */
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !defined(_MSC_VER)
 #define CONFIG_ATOMICS
 #endif
 
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !defined(_MSC_VER)
 /* enable stack limitation */
 #define CONFIG_STACK_CHECK
 #endif
@@ -196,7 +198,7 @@
     JS_URI_ERROR,
     JS_INTERNAL_ERROR,
     JS_AGGREGATE_ERROR,
-    
+
     JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */
 } JSErrorEnum;
 
@@ -259,7 +261,7 @@
        by the garbage collector) */
     struct list_head gc_obj_list;
     /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */
-    struct list_head gc_zero_ref_count_list; 
+    struct list_head gc_zero_ref_count_list;
     struct list_head tmp_obj_list; /* used during GC */
     JSGCPhaseEnum gc_phase : 8;
     size_t malloc_gc_threshold;
@@ -270,7 +272,7 @@
     uintptr_t stack_size; /* in bytes, 0 if no limit */
     uintptr_t stack_top;
     uintptr_t stack_limit; /* lower stack limit */
-    
+
     JSValue current_exception;
     /* true if inside an out of memory error, to avoid recursing */
     BOOL in_out_of_memory : 8;
@@ -282,7 +284,7 @@
 
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
-    
+
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
@@ -292,7 +294,7 @@
     BOOL can_block : 8; /* TRUE if Atomics.wait can block */
     /* used to allocate, free and clone SharedArrayBuffers */
     JSSharedArrayBufferFunctions sab_funcs;
-    
+
     /* Shape hash table */
     int shape_hash_bits;
     int shape_hash_size;
@@ -333,8 +335,12 @@
     int arg_count;
     int js_mode; /* 0 or JS_MODE_MATH for C functions */
     /* only used in generators. Current stack pointer value. NULL if
-       the function is running. */ 
+       the function is running. */
     JSValue *cur_sp;
+#ifdef CONFIG_DEBUGGER
+    JSValue* pthis;   /* reference to this value, needed by debugger to report 'this' */
+#endif // CONFIG_DEBUGGER
+
 } JSStackFrame;
 
 typedef enum {
@@ -367,9 +373,9 @@
 
             /* 0 : the JSVarRef is on the stack. header.link is an element
                of JSStackFrame.var_ref_list.
-               1 : the JSVarRef is detached. header.link has the normal meanning 
+               1 : the JSVarRef is detached. header.link has the normal meanning
             */
-            uint8_t is_detached : 1; 
+            uint8_t is_detached : 1;
             uint8_t is_arg : 1;
             uint16_t var_idx; /* index of the corresponding function variable on
                                  the stack */
@@ -455,7 +461,12 @@
     /* if NULL, eval is not supported */
     JSValue (*eval_internal)(JSContext *ctx, JSValueConst this_obj,
                              const char *input, size_t input_len,
-                             const char *filename, int flags, int scope_idx);
+                             const char *filename, int flags, int scope_idx, int line_no);
+#ifdef CONFIG_DEBUGGER
+    JSDebuggerCheckLineNoF* debugger_check_line_no;
+    BOOL                    debugger_enabled;
+#endif
+
     void *user_opaque;
 };
 
@@ -546,7 +557,7 @@
     JSAtom var_name;
     /* index into fd->scopes of this variable lexical scope */
     int scope_level;
-    /* during compilation: 
+    /* during compilation:
         - if scope_level = 0: scope in which the variable is defined
         - if scope_level != 0: index into fd->vars of the next
           variable in the same or enclosing lexical scope
@@ -554,7 +565,7 @@
        index into fd->vars of the next
        variable in the same or enclosing lexical scope
     */
-    int scope_next;    
+    int scope_next;
     uint8_t is_const : 1;
     uint8_t is_lexical : 1;
     uint8_t is_captured : 1;
@@ -801,7 +812,7 @@
     BOOL eval_mark : 8; /* temporary use during js_evaluate_module() */
     /* true if evaluation yielded an exception. It is saved in
        eval_exception */
-    BOOL eval_has_exception : 8; 
+    BOOL eval_has_exception : 8;
     JSValue eval_exception;
     JSValue meta_obj; /* for import.meta */
 };
@@ -863,13 +874,52 @@
     JSShapeProperty prop[0]; /* prop_size elements */
 };
 
+#ifdef CONFIG_STORAGE
+
+struct JSStorage;
+struct JSPersitentBlock {
+  struct JSStorage* storage;
+  uint32_t oid; /* dybase object id */
+  JS_PERSISTENT_STATUS status;
+};
+
+int js_load_persistent_object(JSContext *ctx, JSValueConst obj);
+int js_free_persistent_object(JSRuntime *rt, JSValueConst obj);
+
+#define MARK_MODIFIED_OBJ(p) \
+  if (p->persistent) \
+    p->persistent->status = JS_PERSISTENT_MODIFIED;
+
+#define MARK_MODIFIED_VALUE(obj) \
+  if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) { \
+    JSObject *p = JS_VALUE_GET_OBJ(obj); \
+    MARK_MODIFIED_OBJ(p); \
+  }
+
+#define PRELOAD_PERSISTENT_OBJ(p) \
+    if (p->persistent && (p->persistent->status == JS_PERSISTENT_DORMANT)) \
+      js_load_persistent_object(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
+
+#define PRELOAD_PERSISTENT_VALUE(obj) \
+  if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) { \
+    JSObject *p = JS_VALUE_GET_OBJ(obj); \
+    PRELOAD_PERSISTENT_OBJ(p); \
+  }
+
+#else
+#define MARK_MODIFIED_OBJ(p);
+#define MARK_MODIFIED_VALUE(obj);
+#define PRELOAD_PERSISTENT_OBJ(p);
+#define PRELOAD_PERSISTENT_VALUE(p);
+#endif // CONFIG_STORAGE
+
 struct JSObject {
     union {
         JSGCObjectHeader header;
         struct {
             int __gc_ref_count; /* corresponds to header.ref_count */
             uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
-            
+
             uint8_t extensible : 1;
             uint8_t free_mark : 1; /* only used when freeing objects with cycles */
             uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */
@@ -929,7 +979,7 @@
                 struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */
             } u1;
             union {
-                JSValue *values;        /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */ 
+                JSValue *values;        /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */
                 void *ptr;              /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */
                 int8_t *int8_ptr;       /* JS_CLASS_INT8_ARRAY */
                 uint8_t *uint8_ptr;     /* JS_CLASS_UINT8_ARRAY, JS_CLASS_UINT8C_ARRAY */
@@ -948,6 +998,10 @@
         JSValue object_data;    /* for JS_SetObjectData(): 8/16/16 bytes */
     } u;
     /* byte sizes: 40/48/72 */
+#ifdef CONFIG_STORAGE
+    struct JSPersitentBlock* persistent; /* persistence data, used only for JS_CLASS_OBJECT  */
+#endif
+
 };
 enum {
     __JS_ATOM_NULL = JS_ATOM_NULL,
@@ -1021,7 +1075,7 @@
                                             JSValue val, BOOL is_array_ctor);
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
                              JSValueConst val, int flags, int scope_idx);
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+JSValue  __js_printf_like(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
 static __maybe_unused void JS_DumpString(JSRuntime *rt,
                                                   const JSString *p);
@@ -1187,7 +1241,7 @@
                                            JS_MarkFunc *mark_func);
 static JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                const char *input, size_t input_len,
-                               const char *filename, int flags, int scope_idx);
+                               const char *filename, int flags, int scope_idx, int line_no);
 static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
 static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
                                JS_MarkFunc *mark_func);
@@ -1628,7 +1682,7 @@
     init_list_head(&rt->gc_obj_list);
     init_list_head(&rt->gc_zero_ref_count_list);
     rt->gc_phase = JS_GC_PHASE_NONE;
-    
+
 #ifdef DUMP_LEAKS
     init_list_head(&rt->string_list);
 #endif
@@ -2205,6 +2259,13 @@
     return JS_DupValue(ctx, ctx->class_proto[class_id]);
 }
 
+JSValue JS_GetClassName(JSContext *ctx, JSClassID class_id)
+{
+  JSRuntime *rt = ctx->rt;
+  assert(class_id < rt->class_count);
+  return JS_AtomToString(ctx,rt->class_array[class_id].class_name);
+}
+
 typedef enum JSFreeModuleEnum {
     JS_FREE_MODULE_ALL,
     JS_FREE_MODULE_NOT_RESOLVED,
@@ -2278,7 +2339,7 @@
     if (--ctx->header.ref_count > 0)
         return;
     assert(ctx->header.ref_count == 0);
-    
+
 #ifdef DUMP_ATOMS
     JS_DumpAtoms(ctx->rt);
 #endif
@@ -2496,25 +2557,25 @@
     }
     printf("%d", p->header.ref_count);
     sep = (p->header.ref_count == 1) ? '\"' : '\'';
-    putchar(sep);
+    printf("%c",sep);
     for(i = 0; i < p->len; i++) {
         if (p->is_wide_char)
             c = p->u.str16[i];
         else
             c = p->u.str8[i];
         if (c == sep || c == '\\') {
-            putchar('\\');
-            putchar(c);
+          printf("%c", '\\');
+          printf("%c",c);
         } else if (c >= ' ' && c <= 126) {
-            putchar(c);
+          printf("%c", c);
         } else if (c == '\n') {
-            putchar('\\');
-            putchar('n');
+          printf("%c", '\\');
+          printf("%c", 'n');
         } else {
             printf("\\u%04x", c);
         }
     }
-    putchar(sep);
+    printf("%c", sep);
 }
 
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt)
@@ -2611,7 +2672,7 @@
     return 0;
 }
 
-static JSAtom JS_DupAtomRT(JSRuntime *rt, JSAtom v)
+JSAtom JS_DupAtomRT(JSRuntime *rt, JSAtom v)
 {
     JSAtomStruct *p;
 
@@ -2635,7 +2696,7 @@
     return v;
 }
 
-static JSAtomKindEnum JS_AtomGetKind(JSContext *ctx, JSAtom v)
+JSAtomKindEnum JS_AtomGetKind(JSContext *ctx, JSAtom v)
 {
     JSRuntime *rt;
     JSAtomStruct *p;
@@ -2855,6 +2916,18 @@
     return __JS_NewAtom(rt, p, atom_type);
 }
 
+JSAtom JS_NewAtomLenRT(JSRuntime *rt, const char *str, int len)
+{
+    return __JS_NewAtomInit(rt, str, len, JS_ATOM_TYPE_STRING);
+}
+
+JSAtom JS_NewAtomSymbolLenRT(JSRuntime *rt, const char *str, int len)
+{
+  return __JS_NewAtomInit(rt, str, len, JS_ATOM_TYPE_SYMBOL);
+}
+
+
+
 static JSAtom __JS_FindAtom(JSRuntime *rt, const char *str, size_t len,
                             int atom_type)
 {
@@ -3029,8 +3102,8 @@
 #define ATOM_GET_STR_BUF_SIZE 64
 
 /* Should only be used for debug. */
-static const char *JS_AtomGetStrRT(JSRuntime *rt, char *buf, int buf_size,
-                                   JSAtom atom)
+const char *JS_AtomGetStrRT(JSRuntime *rt, char *buf, int buf_size,
+                            JSAtom atom)
 {
     if (__JS_AtomIsTaggedInt(atom)) {
         snprintf(buf, buf_size, "%u", __JS_AtomToUInt32(atom));
@@ -3078,7 +3151,7 @@
     return buf;
 }
 
-static const char *JS_AtomGetStr(JSContext *ctx, char *buf, int buf_size, JSAtom atom)
+const char *JS_AtomGetStr(JSContext *ctx, char *buf, int buf_size, JSAtom atom)
 {
     return JS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);
 }
@@ -3122,7 +3195,7 @@
 
 /* return TRUE if the atom is an array index (i.e. 0 <= index <=
    2^32-2 and return its value */
-static BOOL JS_AtomIsArrayIndex(JSContext *ctx, uint32_t *pval, JSAtom atom)
+JS_BOOL JS_AtomIsArrayIndex(JSContext *ctx, uint32_t *pval, JSAtom atom)
 {
     if (__JS_AtomIsTaggedInt(atom)) {
         *pval = __JS_AtomToUInt32(atom);
@@ -3145,6 +3218,23 @@
     }
 }
 
+JS_BOOL JS_AtomIsSymbol(JSContext *ctx,JSAtom atom)
+{
+  if (__JS_AtomIsTaggedInt(atom)) {
+    return FALSE;
+  }
+  else {
+    JSRuntime *rt = ctx->rt;
+    JSAtomStruct *p;
+    uint32_t val;
+
+    assert(atom < rt->atom_size);
+    p = rt->atom_array[atom];
+    return p->atom_type != JS_ATOM_TYPE_STRING;
+  }
+}
+
+
 /* This test must be fast if atom is not a numeric index (e.g. a
    method name). Return JS_UNDEFINED if not a numeric
    index. JS_EXCEPTION can also be returned. */
@@ -3330,7 +3420,7 @@
     const char *cstr;
     char *cstr2;
     size_t len, len1;
-    
+
     str = JS_AtomToString(ctx, name);
     if (JS_IsException(str))
         return JS_ATOM_NULL;
@@ -3868,7 +3958,7 @@
     uint32_t c;
     StringBuffer b_s, *b = &b_s;
     size_t len1;
-    
+
     p_start = (const uint8_t *)buf;
     p_end = p_start + buf_len;
     p = p_start;
@@ -4360,7 +4450,7 @@
     sh->prop_size = prop_size;
     sh->prop_count = 0;
     sh->deleted_prop_count = 0;
-    
+
     /* insert in the hash table */
     sh->hash = shape_initial_hash(proto);
     sh->is_hashed = TRUE;
@@ -4520,7 +4610,7 @@
     uint32_t new_hash_size, i, j, new_hash_mask, new_size;
     JSShapeProperty *old_pr, *pr;
     JSProperty *prop, *new_prop;
-    
+
     sh = p->shape;
     assert(!sh->is_hashed);
 
@@ -4542,7 +4632,7 @@
     list_del(&old_sh->header.link);
     memcpy(sh, old_sh, sizeof(JSShape));
     list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
-    
+
     memset(prop_hash_end(sh) - new_hash_size, 0,
            sizeof(prop_hash_end(sh)[0]) * new_hash_size);
 
@@ -4571,7 +4661,7 @@
 
     p->shape = sh;
     js_free(ctx, get_alloc_from_shape(old_sh));
-    
+
     /* reduce the size of the object properties */
     new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);
     if (new_prop)
@@ -4698,7 +4788,7 @@
     struct list_head *el;
     JSObject *p;
     JSGCObjectHeader *gp;
-    
+
     printf("JSShapes: {\n");
     printf("%5s %4s %14s %5s %5s %s\n", "SLOT", "REFS", "PROTO", "SIZE", "COUNT", "PROPS");
     for(i = 0; i < rt->shape_hash_size; i++) {
@@ -4740,6 +4830,9 @@
     p->first_weak_ref = NULL;
     p->u.opaque = NULL;
     p->shape = sh;
+#ifdef CONFIG_STORAGE
+    p->persistent = NULL;
+#endif // CONFIG_STORAGE
     p->prop = js_malloc(ctx, sizeof(JSProperty) * sh->prop_size);
     if (unlikely(!p->prop)) {
         js_free(ctx, p);
@@ -4905,6 +4998,19 @@
     return -1;
 }
 
+__exception int JS_ThisTimeValue(JSContext *ctx, double *valp, JSValueConst this_val);
+
+JS_BOOL JS_IsDate(JSContext *ctx, JSValueConst obj, double* ms_since_1970) {
+  if (JS_GetClassID(obj, NULL) != JS_CLASS_DATE)
+    return 0;
+  double v;
+  if (JS_ThisTimeValue(ctx, &v, obj))
+    return 0;
+  if (ms_since_1970)
+    *ms_since_1970 = v;
+  return 1;
+}
+
 JSValue JS_NewObjectClass(JSContext *ctx, int class_id)
 {
     return JS_NewObjectProtoClass(ctx, ctx->class_proto[class_id], class_id);
@@ -5026,7 +5132,7 @@
     JSValue func_obj;
     JSObject *p;
     JSAtom name_atom;
-    
+
     func_obj = JS_NewObjectProtoClass(ctx, proto_val, JS_CLASS_C_FUNCTION);
     if (JS_IsException(func_obj))
         return func_obj;
@@ -5399,6 +5505,11 @@
     JSShape *sh;
     JSShapeProperty *pr;
 
+#ifdef CONFIG_STORAGE
+    if (p->persistent)
+      js_free_persistent_object(rt, JS_MKPTR(JS_TAG_OBJECT, p));
+#endif
+
     p->free_mark = 1; /* used to tell the object is invalid when
                          freeing cycles */
     /* free all the fields */
@@ -5457,7 +5568,7 @@
 {
     struct list_head *el;
     JSGCObjectHeader *p;
-    
+
     rt->gc_phase = JS_GC_PHASE_DECREF;
     for(;;) {
         el = rt->gc_zero_ref_count_list.next;
@@ -5689,7 +5800,7 @@
 {
     struct list_head *el, *el1;
     JSGCObjectHeader *p;
-    
+
     init_list_head(&rt->tmp_obj_list);
 
     /* decrement the refcount of all the children of all the GC
@@ -5736,7 +5847,7 @@
         p->mark = 0; /* reset the mark for the next GC call */
         mark_children(rt, p, gc_scan_incref_child);
     }
-    
+
     /* restore the refcount of the objects to be deleted. */
     list_for_each(el, &rt->tmp_obj_list) {
         p = list_entry(el, JSGCObjectHeader, link);
@@ -5782,7 +5893,7 @@
         }
     }
     rt->gc_phase = JS_GC_PHASE_NONE;
-           
+
     list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {
         p = list_entry(el, JSGCObjectHeader, link);
         assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||
@@ -6194,7 +6305,7 @@
 #ifdef CONFIG_BIGNUM
             "BigNum "
 #endif
-            CONFIG_VERSION " version, %d-bit, malloc limit: %"PRId64"\n\n",
+            QUICKJS_VERSION " version, %d-bit, malloc limit: %"PRId64"\n\n",
             (int)sizeof(void *) * 8, (int64_t)(ssize_t)s->malloc_limit);
 #if 1
     if (rt) {
@@ -6449,7 +6560,7 @@
     JSProperty *pr;
     JSShapeProperty *prs;
     JSValueConst val;
-    
+
     if (JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)
         return NULL;
     prs = find_own_property(&pr, JS_VALUE_GET_OBJ(func), JS_ATOM_name);
@@ -6480,7 +6591,7 @@
     const char *str1;
     JSObject *p;
     BOOL backtrace_barrier;
-    
+
     js_dbuf_init(ctx, &dbuf);
     if (filename) {
         dbuf_printf(&dbuf, "    at %s", filename);
@@ -6604,7 +6715,7 @@
     return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2,3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6615,7 +6726,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2,3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6626,7 +6737,7 @@
     return val;
 }
 
-static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
+static int __js_printf_like(3,4) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 {
     va_list ap;
 
@@ -6642,7 +6753,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue __js_printf_like(3,4) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowTypeError(ctx, fmt,
@@ -6650,7 +6761,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue __js_printf_like(3,4) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowSyntaxError(ctx, fmt,
@@ -6673,7 +6784,7 @@
     }
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2,3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6684,7 +6795,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2,3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6695,7 +6806,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2,3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6909,6 +7020,10 @@
     return val;
 }
 
+JSValue JS_GetPrototypeOfDate(JSContext *ctx) {
+  return JS_DupValue(ctx, ctx->class_proto[JS_CLASS_DATE]);
+}
+
 /* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */
 JSValue JS_GetPrototype(JSContext *ctx, JSValueConst obj)
 {
@@ -7118,6 +7233,8 @@
         p = JS_VALUE_GET_OBJ(obj);
     }
 
+    PRELOAD_PERSISTENT_OBJ(p);
+
     for(;;) {
         prs = find_own_property(&pr, p, prop);
         if (prs) {
@@ -7320,7 +7437,7 @@
     JSProperty *pr;
     JSValue brand;
     JSAtom brand_atom;
-    
+
     if (unlikely(JS_VALUE_GET_TAG(home_obj) != JS_TAG_OBJECT)) {
         JS_ThrowTypeErrorNotAnObject(ctx);
         return -1;
@@ -7342,7 +7459,7 @@
         brand = JS_DupValue(ctx, pr->u.value);
     }
     brand_atom = js_symbol_to_atom(ctx, brand);
-    
+
     if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
         JS_ThrowTypeErrorNotAnObject(ctx);
         JS_FreeAtom(ctx, brand_atom);
@@ -7363,7 +7480,7 @@
     JSShapeProperty *prs;
     JSProperty *pr;
     JSValueConst brand;
-    
+
     /* get the home object of 'func' */
     if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)) {
     not_obj:
@@ -7385,7 +7502,7 @@
     /* safety check */
     if (unlikely(JS_VALUE_GET_TAG(brand) != JS_TAG_SYMBOL))
         goto not_obj;
-    
+
     /* get the brand array of 'obj' */
     if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
         goto not_obj;
@@ -7433,7 +7550,7 @@
         return 1;
 }
 
-static void js_free_prop_enum(JSContext *ctx, JSPropertyEnum *tab, uint32_t len)
+void js_free_prop_enum(JSContext *ctx, JSPropertyEnum *tab, uint32_t len)
 {
     uint32_t i;
     if (tab) {
@@ -7460,7 +7577,7 @@
     BOOL is_enumerable, num_sorted;
     uint32_t num_key;
     JSAtomKindEnum kind;
-    
+
     /* clear pointer for consistency in case of failure */
     *ptab = NULL;
     *plen = 0;
@@ -7472,6 +7589,10 @@
     exotic_keys_count = 0;
     exotic_count = 0;
     tab_exotic = NULL;
+
+    PRELOAD_PERSISTENT_OBJ(p);
+
+
     sh = p->shape;
     for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
         atom = prs->atom;
@@ -7656,6 +7777,8 @@
     JSShapeProperty *prs;
     JSProperty *pr;
 
+    PRELOAD_PERSISTENT_OBJ(p);
+
 retry:
     prs = find_own_property(&pr, p, prop);
     if (prs) {
@@ -7784,6 +7907,7 @@
                 obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
                 ret = em->has_property(ctx, obj1, prop);
                 JS_FreeValue(ctx, obj1);
+                if(ret != JS_PROCEED_WITH_DEFAULT)
                 return ret;
             }
         }
@@ -8320,7 +8444,7 @@
     JSPropertyDescriptor desc;
     JSValue obj1;
     JSObject *p;
-    
+
     obj1 = JS_DupValue(ctx, obj);
     for(;;) {
         p = JS_VALUE_GET_OBJ(obj1);
@@ -8374,7 +8498,7 @@
         JS_FreeValue(ctx, val);
         return JS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");
     }
-    
+
     p = JS_VALUE_GET_OBJ(this_obj);
 
     /* modify the property in this_obj if it already exists */
@@ -8451,6 +8575,8 @@
         }
     }
     p = JS_VALUE_GET_OBJ(this_obj);
+    MARK_MODIFIED_OBJ(p);
+
 retry:
     prs = find_own_property(&pr, p, prop);
     if (prs) {
@@ -8888,8 +9014,10 @@
             const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
             if (em) {
                 if (em->define_own_property) {
-                    return em->define_own_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),
+                    int r = em->define_own_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),
                                                    prop, val, getter, setter, flags);
+                    if (r != JS_PROCEED_WITH_DEFAULT)
+                      return r;
                 }
                 ret = JS_IsExtensible(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
                 if (ret < 0)
@@ -9396,7 +9524,7 @@
     JSShapeProperty *prs;
     JSValueConst val;
     JSString *p;
-    
+
     prs = find_own_property(&pr, JS_VALUE_GET_OBJ(obj), JS_ATOM_name);
     if (!prs)
         return FALSE;
@@ -9656,7 +9784,7 @@
         return 0;
     }
     flags = JS_PROP_THROW_STRICT;
-    if (is_strict_mode(ctx)) 
+    if (is_strict_mode(ctx))
         flags |= JS_PROP_NO_ADD;
     return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, flags);
 }
@@ -9669,7 +9797,7 @@
     JSValue obj1;
     JSObject *p;
     int res;
-    
+
     obj1 = JS_ToObject(ctx, obj);
     if (JS_IsException(obj1))
         return -1;
@@ -9703,6 +9831,23 @@
     return res;
 }
 
+BOOL JS_IsFunctionOfThisRealm(JSContext *ctx, JSValueConst val)
+{
+  JSObject *p;
+  if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
+    return FALSE;
+  p = JS_VALUE_GET_OBJ(val);
+  switch (p->class_id) {
+    case JS_CLASS_BYTECODE_FUNCTION:
+      return p->u.func.function_bytecode->realm == ctx;
+    case JS_CLASS_C_FUNCTION:
+      return p->u.cfunc.realm == ctx;
+    default:
+      return FALSE;
+  }
+}
+
+
 BOOL JS_IsFunction(JSContext *ctx, JSValueConst val)
 {
     JSObject *p;
@@ -9814,6 +9959,16 @@
     return p;
 }
 
+JSClassID JS_GetClassID(JSValueConst obj, void** ppopaque) {
+  JSObject *p;
+  if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
+    return 0;
+  p = JS_VALUE_GET_OBJ(obj);
+  if(ppopaque)
+    *ppopaque = p->u.opaque;
+  return p->class_id;
+}
+
 #define HINT_STRING  0
 #define HINT_NUMBER  1
 #define HINT_NONE    2
@@ -9916,7 +10071,7 @@
     p = JS_VALUE_GET_OBJ(obj);
     return p->is_HTMLDDA;
 }
-                         
+
 static int JS_ToBoolFree(JSContext *ctx, JSValue val)
 {
     uint32_t tag = JS_VALUE_GET_TAG(val);
@@ -10018,11 +10173,11 @@
 {
     double d;
     int c;
-    
+
     if (!is_float || radix != 10) {
         uint64_t n_max, n;
         int int_exp, is_neg;
-        
+
         is_neg = 0;
         if (*p == '-') {
             is_neg = 1;
@@ -10070,7 +10225,7 @@
 /* accept _ between digits as a digit separator */
 #define ATOD_ACCEPT_UNDERSCORES  (1 << 5)
 /* allow a suffix to override the type */
-#define ATOD_ACCEPT_SUFFIX    (1 << 6) 
+#define ATOD_ACCEPT_SUFFIX    (1 << 6)
 /* default type */
 #define ATOD_TYPE_MASK        (3 << 7)
 #define ATOD_TYPE_FLOAT64     (0 << 7)
@@ -10079,7 +10234,7 @@
 #define ATOD_TYPE_BIG_DECIMAL (3 << 7)
 /* assume bigint mode: floats are parsed as integers if no decimal
    point nor exponent */
-#define ATOD_MODE_BIGINT      (1 << 9) 
+#define ATOD_MODE_BIGINT      (1 << 9)
 /* accept -0x1 */
 #define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)
 
@@ -10109,7 +10264,7 @@
     bf_t *a;
     int ret;
     JSValue val;
-    
+
     val = JS_NewBigFloat(ctx);
     if (JS_IsException(val))
         return val;
@@ -10135,7 +10290,7 @@
     bfdec_t *a;
     int ret;
     JSValue val;
-    
+
     val = JS_NewBigDecimal(ctx);
     if (JS_IsException(val))
         return val;
@@ -10169,11 +10324,11 @@
     int i, j, len;
     BOOL buf_allocated = FALSE;
     JSValue val;
-    
+
     /* optional separator between digits */
     sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;
     has_legacy_octal = FALSE;
-    
+
     p = str;
     p_start = p;
     is_neg = 0;
@@ -10237,7 +10392,11 @@
             } else
 #endif
             {
+#ifdef _MSC_VER
+                double d = INFINITY;
+#else
                 double d = 1.0 / 0.0;
+#endif
                 if (is_neg)
                     d = -d;
                 val = JS_NewFloat64(ctx, d);
@@ -10378,7 +10537,7 @@
         val = JS_NewFloat64(ctx, d);
     }
 #endif
-    
+
 done:
     if (buf_allocated)
         js_free_rt(ctx->rt, buf);
@@ -10460,7 +10619,7 @@
             const char *str;
             const char *p;
             size_t len;
-            
+
             str = JS_ToCStringLen(ctx, &len, val);
             JS_FreeValue(ctx, val);
             if (!str)
@@ -11793,7 +11952,7 @@
         }
         printf(" }");
     }
-    
+
     if (js_class_has_bytecode(p->class_id)) {
         JSFunctionBytecode *b = p->u.func.function_bytecode;
         JSVarRef **var_refs;
@@ -11980,6 +12139,39 @@
     }
 }
 
+int JS_IsTuple(JSContext *ctx, JSValueConst val) {
+  /* isArray and has tag property */
+  int ret;
+  ret = JS_IsArray(ctx, val);
+  if (ret < 0)
+    return -1;
+  else if (ret > 0)
+    return JS_HasProperty(ctx, val, JS_ATOM_tag);
+  return FALSE;
+}
+
+JSValue JS_GetTupleTag(JSContext *ctx, JSValueConst this_obj)
+{
+  return JS_GetProperty(ctx, this_obj, JS_ATOM_tag);
+}
+
+/* return -1 if exception (proxy case) or TRUE/FALSE */
+int JS_IsObjectPlain(JSContext *ctx, JSValueConst val)
+{
+  JSObject *p;
+  if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {
+    p = JS_VALUE_GET_OBJ(val);
+    if (unlikely(p->class_id == JS_CLASS_PROXY))
+      return !js_proxy_isArray(ctx, val);
+    else
+      return p->class_id == JS_CLASS_OBJECT;
+  }
+  else {
+    return FALSE;
+  }
+}
+
+
 static double js_pow(double a, double b)
 {
     if (unlikely(!isfinite(b)) && fabs(a) == 1) {
@@ -12085,7 +12277,7 @@
     uint32_t tag;
     JSBigDecimal *p;
     bfdec_t *r;
-    
+
     tag = JS_VALUE_GET_NORM_TAG(val);
     switch(tag) {
     case JS_TAG_BIG_DECIMAL:
@@ -12106,7 +12298,7 @@
     const char *str, *p;
     size_t len;
     int flags;
-    
+
     str = JS_ToCStringLen(ctx, &len, val);
     JS_FreeValue(ctx, val);
     if (!str)
@@ -12222,7 +12414,7 @@
     } else {
         bf_t a_s, *a, *r;
         int ret;
-        JSValue res; 
+        JSValue res;
 
         res = JS_NewBigInt(ctx);
         if (JS_IsException(res))
@@ -12324,7 +12516,7 @@
 {
     int64_t v;
     bf_t *a;
-    
+
     if (JS_VALUE_GET_TAG(val) != JS_TAG_BIG_INT)
         return val; /* fail safe */
     a = JS_GetBigInt(val);
@@ -12452,10 +12644,10 @@
     JSOverloadableOperatorEnum ovop;
     JSObject *p;
     JSValueConst args[2];
-    
+
     if (!ctx->allow_operator_overloading)
         return 0;
-    
+
     opset2_obj = JS_UNDEFINED;
     opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);
     if (JS_IsException(opset1_obj))
@@ -12484,7 +12676,7 @@
     }
 
     ovop = get_ovop_from_opcode(op);
-    
+
     if (opset1->operator_counter == opset2->operator_counter) {
         p = opset1->self_ops[ovop];
     } else if (opset1->operator_counter > opset2->operator_counter) {
@@ -12509,7 +12701,7 @@
     } else {
         new_op1 = JS_DupValue(ctx, op1);
     }
-    
+
     if (opset2->is_primitive) {
         if (is_numeric) {
             new_op2 = JS_ToNumeric(ctx, op2);
@@ -12526,7 +12718,7 @@
 
     /* XXX: could apply JS_ToPrimitive() if primitive type so that the
        operator function does not get a value object */
-    
+
     method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
     if (ovop == JS_OVOP_LESS && (op == OP_lte || op == OP_gt)) {
         args[0] = new_op2;
@@ -12637,7 +12829,7 @@
 
     if (!ctx->allow_operator_overloading)
         return 0;
-    
+
     opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);
     if (JS_IsException(opset1_obj))
         goto exception;
@@ -12693,7 +12885,7 @@
     bf_t a_s, *r, *a;
     int ret, v;
     JSValue res;
-    
+
     if (op == OP_plus && !is_math_mode(ctx)) {
         JS_ThrowTypeError(ctx, "bigint argument with unary +");
         JS_FreeValue(ctx, op1);
@@ -12745,7 +12937,7 @@
     bf_t a_s, *r, *a;
     int ret, v;
     JSValue res;
-    
+
     if (op == OP_plus && !is_math_mode(ctx)) {
         JS_ThrowTypeError(ctx, "bigfloat argument with unary +");
         JS_FreeValue(ctx, op1);
@@ -12794,7 +12986,7 @@
     bfdec_t *r, *a;
     int ret, v;
     JSValue res;
-    
+
     if (op == OP_plus && !is_math_mode(ctx)) {
         JS_ThrowTypeError(ctx, "bigdecimal argument with unary +");
         JS_FreeValue(ctx, op1);
@@ -12954,7 +13146,7 @@
 {
     JSValue op1, val;
     int ret;
-    
+
     op1 = sp[-1];
     if (JS_IsObject(op1)) {
         ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);
@@ -12991,7 +13183,7 @@
     bf_t a_s, b_s, *r, *a, *b;
     int ret;
     JSValue res;
-    
+
     res = JS_NewBigFloat(ctx);
     if (JS_IsException(res)) {
         JS_FreeValue(ctx, op1);
@@ -13052,7 +13244,7 @@
     bf_t a_s, b_s, *r, *a, *b;
     int ret;
     JSValue res;
-    
+
     res = JS_NewBigInt(ctx);
     if (JS_IsException(res))
         goto fail;
@@ -13239,7 +13431,7 @@
     if (JS_IsException(res))
         goto fail;
     r = JS_GetBigDecimal(res);
-    
+
     a = JS_ToBigDecimal(ctx, op1);
     if (!a)
         goto fail;
@@ -13666,7 +13858,7 @@
 {
     bf_t a_s, b_s, *a, *b;
     int res;
-    
+
     a = JS_ToBigFloat(ctx, &a_s, op1);
     if (!a) {
         JS_FreeValue(ctx, op2);
@@ -13728,7 +13920,7 @@
     }
     a = JS_ToBigDecimal(ctx, op1);
     b = JS_ToBigDecimal(ctx, op2);
-    
+
     switch(op) {
     case OP_lt:
         res = bfdec_cmp_lt(a, b); /* if NaN return false */
@@ -14117,7 +14309,7 @@
     bf_t r_s, *r = &r_s;
     double d;
     int ret;
-    
+
     /* always convert to Float64 */
     bf_init(ctx->bf_ctx, r);
     ret = bf_mul_pow_radix(r, a, 10, exponent,
@@ -14839,7 +15031,7 @@
         {
             JSObject *p;
             p = JS_VALUE_GET_OBJ(op1);
-            if (unlikely(p->is_HTMLDDA)) 
+            if (unlikely(p->is_HTMLDDA))
                 atom = JS_ATOM_undefined;
             else if (JS_IsFunction(ctx, op1))
                 atom = JS_ATOM_function;
@@ -14987,6 +15179,50 @@
     return val;
 }
 
+/**/
+JSValue JS_NewFastArray(JSContext *ctx, int argc, JSValueConst *argv)
+{
+  JSValue val, *tab;
+  JSProperty *pr;
+  JSObject *p;
+  int i;
+
+  val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_ARRAY);
+  if (JS_IsException(val))
+    return val;
+  p = JS_VALUE_GET_OBJ(val);
+
+  /* add the length field (cannot fail) */
+  pr = add_property(ctx, p, JS_ATOM_length,
+    JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
+  pr->u.value = JS_NewInt32(ctx, argc);
+
+  /* initialize the fast array part */
+  tab = NULL;
+  if (argc > 0) {
+    tab = js_malloc(ctx, sizeof(tab[0]) * argc);
+    if (!tab) {
+      JS_FreeValue(ctx, val);
+      return JS_EXCEPTION;
+    }
+    for (i = 0; i < argc; i++) {
+      tab[i] = JS_DupValue(ctx, argv[i]);
+    }
+  }
+  p->u.array.u.values = tab;
+  p->u.array.count = argc;
+
+  JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,
+    JS_DupValue(ctx, ctx->array_proto_values),
+    JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
+  return val;
+}
+
+BOOL JS_GetFastArray(JSContext *ctx, JSValueConst obj, JSValue **arrpp, uint32_t *countp) {
+  return js_get_fast_array(ctx, obj, arrpp, countp);
+}
+
+
 #define GLOBAL_VAR_OFFSET 0x40000000
 #define ARGUMENT_VAR_OFFSET 0x20000000
 
@@ -15560,7 +15796,7 @@
     int is_array_iterator;
     JSValue *arrp;
     uint32_t i, count32, pos;
-    
+
     if (JS_VALUE_GET_TAG(sp[-2]) != JS_TAG_INT) {
         JS_ThrowInternalError(ctx, "invalid index for append");
         return -1;
@@ -15634,7 +15870,7 @@
     return -1;
 }
 
-static __exception int JS_CopyDataProperties(JSContext *ctx,
+__exception int JS_CopyDataProperties(JSContext *ctx,
                                              JSValueConst target,
                                              JSValueConst source,
                                              JSValueConst excluded,
@@ -15648,7 +15884,7 @@
     int ret, gpn_flags;
     JSPropertyDescriptor desc;
     BOOL is_enumerable;
-    
+
     if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)
         return 0;
 
@@ -15669,7 +15905,7 @@
     if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
                                        gpn_flags))
         return -1;
-    
+
     for (i = 0; i < tab_atom_count; i++) {
         if (pexcl) {
             ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
@@ -16032,7 +16268,7 @@
     sf->prev_frame = prev_sf;
     rt->current_stack_frame = sf;
     ctx = p->u.cfunc.realm; /* change the current realm */
-    
+
 #ifdef CONFIG_BIGNUM
     /* we only propagate the bignum mode as some runtime functions
        test it */
@@ -16179,6 +16415,16 @@
     }
 }
 
+JS_BOOL JS_AreFunctionsOfSameOrigin(JSContext *ctx, JSValue f1, JSValue f2) {
+  if (!JS_IsFunction(ctx, f1)) return 0;
+  if (!JS_IsFunction(ctx, f2)) return 0;
+
+  JSObject *p1 = JS_VALUE_GET_OBJ(f1);
+  JSObject *p2 = JS_VALUE_GET_OBJ(f2);
+
+  return p1->u.func.function_bytecode == p2->u.func.function_bytecode; /* what about native functions ? */
+}
+
 /* argument of OP_special_object */
 typedef enum {
     OP_SPECIAL_OBJECT_ARGUMENTS,
@@ -16210,6 +16456,10 @@
     JSVarRef **var_refs;
     size_t alloca_size;
 
+#ifdef CONFIG_DEBUGGER
+    sf->pthis = &this_obj;
+#endif
+
 #if !DIRECT_DISPATCH
 #define SWITCH(pc)      switch (opcode = *pc++)
 #define CASE(op)        case op
@@ -16220,7 +16470,7 @@
 #define DEF(id, size, n_pop, n_push, f) && case_OP_ ## id,
 #if SHORT_OPCODES
 #define def(id, size, n_pop, n_push, f)
-#else                                                     
+#else
 #define def(id, size, n_pop, n_push, f) && case_default,
 #endif
 #include "quickjs-opcode.h"
@@ -16314,7 +16564,7 @@
     sf->prev_frame = rt->current_stack_frame;
     rt->current_stack_frame = sf;
     ctx = b->realm; /* set the current realm */
-    
+
  restart:
     for(;;) {
         int call_argc;
@@ -16764,7 +17014,7 @@
             JS_FreeValue(ctx, sp[-1]);
             sp -= 2;
             BREAK;
-            
+
         CASE(OP_throw):
             JS_Throw(ctx, *--sp);
             goto exception;
@@ -17579,7 +17829,7 @@
             {
                 JSAtom atom;
                 JSValue val;
-                
+
                 atom = get_u32(pc);
                 pc += 4;
                 val = JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
@@ -17588,7 +17838,7 @@
                 *sp++ = val;
             }
             BREAK;
-            
+
         CASE(OP_get_private_field):
             {
                 JSValue val;
@@ -17741,7 +17991,7 @@
             {
                 int class_flags;
                 JSAtom atom;
-                
+
                 atom = get_u32(pc);
                 class_flags = pc[4];
                 pc += 5;
@@ -18607,6 +18857,17 @@
 
         CASE(OP_nop):
             BREAK;
+
+#ifdef CONFIG_DEBUGGER
+        CASE(OP_line_num) : {
+              uint32_t line_num = get_u32(pc);
+              pc += 4;
+              if (caller_ctx == ctx && caller_ctx->debugger_check_line_no && b->has_debug && b->debug.filename) {
+                caller_ctx->debugger_check_line_no(caller_ctx, b->debug.filename, line_num, pc);
+              }
+            }
+            BREAK;
+#endif
         CASE(OP_is_undefined_or_null):
             if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED ||
                 JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {
@@ -18731,7 +18992,7 @@
 {
     JSObject *p;
     JSContext *realm;
-    
+
     if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
         return ctx;
     p = JS_VALUE_GET_OBJ(func_obj);
@@ -18780,7 +19041,7 @@
 {
     JSValue proto, obj;
     JSContext *realm;
-    
+
     if (JS_IsUndefined(ctor)) {
         proto = JS_DupValue(ctx, ctx->class_proto[class_id]);
     } else {
@@ -18947,7 +19208,7 @@
 
     /* close the closure variables. */
     close_var_refs(rt, sf);
-    
+
     if (sf->arg_buf) {
         /* cannot free the function if it is running */
         assert(sf->cur_sp != NULL);
@@ -19849,6 +20110,8 @@
     TOK_FUNCTION,
     TOK_DEBUGGER,
     TOK_WITH,
+    TOK___FILE__,
+    TOK___DIR__,
     /* FutureReservedWord */
     TOK_CLASS,
     TOK_CONST,
@@ -19993,7 +20256,7 @@
     int var_object_idx; /* -1 if none */
     int arg_var_object_idx; /* -1 if none (var object for the argument scope) */
     int arguments_var_idx; /* -1 if none */
-    int arguments_arg_idx; /* argument variable definition in argument scope, 
+    int arguments_arg_idx; /* argument variable definition in argument scope,
                               -1 if none */
     int func_var_idx; /* variable containing the current function (-1
                          if none, only used if is_func_expr is true) */
@@ -20003,7 +20266,7 @@
     int this_active_func_var_idx; /* variable containg the 'this.active_func' value, -1 if none */
     int home_object_var_idx;
     BOOL need_home_object;
-    
+
     int scope_level;    /* index into fd->scopes if the current lexical scope */
     int scope_first;    /* index into vd->vars of first lexically scoped variable */
     int scope_size;     /* allocated size of fd->scopes array */
@@ -20020,7 +20283,7 @@
     int last_opcode_pos; /* -1 if no last opcode */
     int last_opcode_line_num;
     BOOL use_short_opcodes; /* true if short opcodes are used in byte_code */
-    
+
     LabelSlot *label_slots;
     int label_size; /* allocated size for label_slots[] */
     int label_count;
@@ -20100,6 +20363,9 @@
     BOOL is_module; /* parsing a module */
     BOOL allow_html_comments;
     BOOL ext_json; /* true if accepting JSON superset */
+#ifdef CONFIG_JSX
+    BOOL allow_web_name_token; /* HTML and CSS tokens that accept '-' as part of the nmtoken */
+#endif
 } JSParseState;
 
 typedef struct JSOpCode {
@@ -20230,12 +20496,12 @@
     }
 }
 
-int __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)
+int __js_printf_like(2,3) js_parse_error(JSParseState *s, const char *fmt, ...)
 {
     JSContext *ctx = s->ctx;
     va_list ap;
     int backtrace_flags;
-    
+
     va_start(ap, fmt);
     JS_ThrowError2(ctx, JS_SYNTAX_ERROR, fmt, ap, FALSE);
     va_end(ap);
@@ -20345,6 +20611,13 @@
     uint32_t c;
     StringBuffer b_s, *b = &b_s;
 
+    int multiline_str =
+#ifdef CONFIG_JSX
+      sep == '`' || sep == '<';
+#else
+      sep == '`';
+#endif
+
     /* string */
     if (string_buffer_init(s->ctx, b, 32))
         goto fail;
@@ -20358,19 +20631,31 @@
                     js_parse_error(s, "invalid character in a JSON string");
                 goto fail;
             }
-            if (sep == '`') {
+            if (multiline_str) {
                 if (c == '\r') {
                     if (p[1] == '\n')
                         p++;
                     c = '\n';
                 }
+#ifdef CONFIG_JSX
+                if(c == '\n' && sep == '<')
+                  s->line_num++;
+#endif
                 /* do not update s->line_num */
             } else if (c == '\n' || c == '\r')
                 goto invalid_char;
         }
         p++;
+#ifdef CONFIG_JSX
+        if ((c == '{' || c == '<') && sep == '<') {
+           /* expr start */
+           --p;
+           break;
+        } else
+#endif
         if (c == sep)
             break;
+
         if (c == '$' && *p == '{' && sep == '`') {
             /* template start or middle part */
             p++;
@@ -20585,7 +20870,7 @@
 {
     char *buf, *new_buf;
     size_t size, new_size;
-    
+
     buf = *pbuf;
     size = *psize;
     if (size >= (SIZE_MAX / 3) * 2)
@@ -20615,7 +20900,7 @@
     char ident_buf[128], *buf;
     size_t ident_size, ident_pos;
     JSAtom atom;
-    
+
     p = *pp;
     buf = ident_buf;
     ident_size = sizeof(ident_buf);
@@ -20624,7 +20909,7 @@
         buf[ident_pos++] = '#';
     for(;;) {
         p1 = p;
-        
+
         if (c < 128) {
             buf[ident_pos++] = c;
         } else {
@@ -20637,6 +20922,9 @@
         } else if (c >= 128) {
             c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
         }
+#ifdef CONFIG_JSX
+        if (c == '-' && s->allow_web_name_token) {;} else
+#endif
         if (!lre_js_is_ident_next(c))
             break;
         p = p1;
@@ -20662,11 +20950,11 @@
     int c;
     BOOL ident_has_escape;
     JSAtom atom;
-    
+
     if (js_check_stack_overflow(s->ctx->rt, 0)) {
         return js_parse_error(s, "stack overflow");
     }
-    
+
     free_token(s, &s->token);
 
     p = s->last_ptr = s->buf_ptr;
@@ -20793,14 +21081,14 @@
     case 'm': case 'n': case 'o': case 'p':
     case 'q': case 'r': case 's': case 't':
     case 'u': case 'v': case 'w': case 'x':
-    case 'y': case 'z': 
+    case 'y': case 'z':
     case 'A': case 'B': case 'C': case 'D':
     case 'E': case 'F': case 'G': case 'H':
     case 'I': case 'J': case 'K': case 'L':
     case 'M': case 'N': case 'O': case 'P':
     case 'Q': case 'R': case 'S': case 'T':
     case 'U': case 'V': case 'W': case 'X':
-    case 'Y': case 'Z': 
+    case 'Y': case 'Z':
     case '_':
     case '$':
         /* identifier */
@@ -20839,6 +21127,10 @@
         }
         break;
     case '#':
+#ifdef CONFIG_JSX
+        if (s->allow_web_name_token) goto def_token;
+#endif // CONFIG_JSX
+
         /* private name */
         {
             const uint8_t *p1;
@@ -20884,7 +21176,7 @@
         goto parse_number;
     case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8':
-    case '9': 
+    case '9':
         /* number */
     parse_number:
         {
@@ -21142,7 +21434,7 @@
             case CP_LS:
                 /* XXX: should avoid incrementing line_number, but
                    needed to handle HTML comments */
-                goto line_terminator; 
+                goto line_terminator;
             default:
                 if (lre_is_space(c)) {
                     goto redo;
@@ -21177,7 +21469,7 @@
     char ident_buf[128], *buf;
     size_t ident_size, ident_pos;
     JSAtom atom;
-    
+
     p = *pp;
     buf = ident_buf;
     ident_size = sizeof(ident_buf);
@@ -21209,11 +21501,11 @@
     const uint8_t *p;
     int c;
     JSAtom atom;
-    
+
     if (js_check_stack_overflow(s->ctx->rt, 0)) {
         return js_parse_error(s, "stack overflow");
     }
-    
+
     free_token(s, &s->token);
 
     p = s->last_ptr = s->buf_ptr;
@@ -21323,14 +21615,14 @@
     case 'm': case 'n': case 'o': case 'p':
     case 'q': case 'r': case 's': case 't':
     case 'u': case 'v': case 'w': case 'x':
-    case 'y': case 'z': 
+    case 'y': case 'z':
     case 'A': case 'B': case 'C': case 'D':
     case 'E': case 'F': case 'G': case 'H':
     case 'I': case 'J': case 'K': case 'L':
     case 'M': case 'N': case 'O': case 'P':
     case 'Q': case 'R': case 'S': case 'T':
     case 'U': case 'V': case 'W': case 'X':
-    case 'Y': case 'Z': 
+    case 'Y': case 'Z':
     case '_':
     case '$':
         /* identifier : only pure ascii characters are accepted */
@@ -21357,7 +21649,7 @@
         goto parse_number;
     case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8':
-    case '9': 
+    case '9':
         /* number */
     parse_number:
         {
@@ -21405,7 +21697,7 @@
 {
     const uint8_t *p;
     uint32_t c;
-    
+
     /* skip spaces and comments */
     p = *pp;
     for (;;) {
@@ -21636,7 +21928,7 @@
 static int cpool_add(JSParseState *s, JSValue val)
 {
     JSFunctionDef *fd = s->cur_func;
-    
+
     if (js_resize_array(s->ctx, (void *)&fd->cpool, sizeof(fd->cpool[0]),
                         &fd->cpool_size, fd->cpool_count + 1))
         return -1;
@@ -22022,7 +22314,7 @@
         if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {
             return js_parse_error(s, "invalid redefinition of a variable");
         }
-        
+
         if (fd->is_global_var) {
             JSGlobalVar *hf;
             hf = find_global_var(fd, name);
@@ -22031,7 +22323,7 @@
                 return js_parse_error(s, "invalid redefinition of global identifier");
             }
         }
-        
+
         if (fd->is_eval &&
             (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||
              fd->eval_type == JS_EVAL_TYPE_MODULE) &&
@@ -22302,7 +22594,7 @@
     BOOL is_non_reserved_ident;
     JSAtom name;
     int prop_type;
-    
+
     prop_type = PROP_TYPE_IDENT;
     if (allow_method) {
         if (token_is_pseudo_keyword(s, JS_ATOM_get)
@@ -22528,7 +22820,7 @@
                 if (level >= sizeof(state))
                     goto done;
                 state[level++] = '`';
-            } 
+            }
             break;
         case TOK_EOF:
             goto done;
@@ -22545,7 +22837,7 @@
         case '=':
             bits |= SKIP_HAS_ASSIGNMENT;
             break;
-            
+
         case TOK_DIV_ASSIGN:
             tok_len = 2;
             goto parse_regexp;
@@ -22755,15 +23047,20 @@
 }
 
 /* allow the 'in' binary operator */
-#define PF_IN_ACCEPTED  (1 << 0) 
+#define PF_IN_ACCEPTED  (1 << 0)
 /* allow function calls parsing in js_parse_postfix_expr() */
-#define PF_POSTFIX_CALL (1 << 1) 
+#define PF_POSTFIX_CALL (1 << 1)
 /* allow arrow functions parsing in js_parse_postfix_expr() */
-#define PF_ARROW_FUNC   (1 << 2) 
+#define PF_ARROW_FUNC   (1 << 2)
 /* allow the exponentiation operator in js_parse_unary() */
-#define PF_POW_ALLOWED  (1 << 3) 
+#define PF_POW_ALLOWED  (1 << 3)
 /* forbid the exponentiation operator in js_parse_unary() */
-#define PF_POW_FORBIDDEN (1 << 4) 
+#define PF_POW_FORBIDDEN (1 << 4)
+
+#ifdef CONFIG_OBJECT_LITERAL_CALL
+#define PF_ACCEPT_LCURLY (1 << 5)
+#endif
+
 
 static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags);
 
@@ -22782,7 +23079,7 @@
     int ret, line_num;
     JSParseFunctionEnum func_type;
     const uint8_t *saved_buf_end;
-    
+
     js_parse_get_pos(s, &pos);
     if (has_super) {
         /* spec change: no argument evaluation */
@@ -22829,7 +23126,7 @@
 static void emit_class_field_init(JSParseState *s)
 {
     int label_next;
-    
+
     emit_op(s, OP_scope_get_var);
     emit_atom(s, JS_ATOM_class_fields_init);
     emit_u16(s, s->cur_func->scope_level);
@@ -22837,13 +23134,13 @@
     /* no need to call the class field initializer if not defined */
     emit_op(s, OP_dup);
     label_next = emit_goto(s, OP_if_false, -1);
-    
+
     emit_op(s, OP_scope_get_var);
     emit_atom(s, JS_ATOM_this);
     emit_u16(s, 0);
-    
+
     emit_op(s, OP_swap);
-    
+
     emit_op(s, OP_call_method);
     emit_u16(s, 0);
 
@@ -22868,29 +23165,29 @@
                                              ClassFieldsDef *cf)
 {
     int label_add_brand;
-    
+
     cf->fields_init_fd = js_parse_function_class_fields_init(s);
     if (!cf->fields_init_fd)
         return -1;
 
     s->cur_func = cf->fields_init_fd;
-    
+
     /* XXX: would be better to add the code only if needed, maybe in a
        later pass */
     emit_op(s, OP_push_false); /* will be patched later */
     cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
     label_add_brand = emit_goto(s, OP_if_false, -1);
-    
+
     emit_op(s, OP_scope_get_var);
     emit_atom(s, JS_ATOM_this);
     emit_u16(s, 0);
-    
+
     emit_op(s, OP_scope_get_var);
     emit_atom(s, JS_ATOM_home_object);
     emit_u16(s, 0);
-    
+
     emit_op(s, OP_add_brand);
-    
+
     emit_label(s, label_add_brand);
 
     s->cur_func = s->cur_func->parent;
@@ -22907,7 +23204,7 @@
         }
         /* patch the start of the function to enable the OP_add_brand code */
         cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;
-        
+
         cf->has_brand = TRUE;
     }
     return 0;
@@ -22916,11 +23213,11 @@
 static void emit_class_init_end(JSParseState *s, ClassFieldsDef *cf)
 {
     int cpool_idx;
-        
+
     s->cur_func = cf->fields_init_fd;
     emit_op(s, OP_return_undef);
     s->cur_func = s->cur_func->parent;
-    
+
     cpool_idx = cpool_add(s, JS_NULL);
     cf->fields_init_fd->parent_cpool_idx = cpool_idx;
     emit_op(s, OP_fclosure);
@@ -22943,7 +23240,7 @@
     const uint8_t *class_start_ptr = s->token.ptr;
     const uint8_t *start_ptr;
     ClassFieldsDef class_fields[2];
-        
+
     /* classes are parsed and executed in strict mode */
     saved_js_mode = fd->js_mode;
     fd->js_mode |= JS_MODE_STRICT;
@@ -23006,7 +23303,7 @@
     } else {
         class_name1 = class_name;
     }
-    
+
     emit_op(s, OP_define_class);
     emit_atom(s, class_name1);
     emit_u8(s, class_flags);
@@ -23018,7 +23315,7 @@
         cf->computed_fields_count = 0;
         cf->has_brand = FALSE;
     }
-    
+
     ctor_fd = NULL;
     while (s->token.val != '}') {
         if (s->token.val == ';') {
@@ -23048,7 +23345,7 @@
         }
         is_private = prop_type & PROP_TYPE_PRIVATE;
         prop_type &= ~PROP_TYPE_PRIVATE;
-        
+
         if ((name == JS_ATOM_constructor && !is_static &&
              prop_type != PROP_TYPE_IDENT) ||
             (name == JS_ATOM_prototype && is_static) ||
@@ -23094,7 +23391,7 @@
                 if (is_set) {
                     JSAtom setter_name;
                     int ret;
-                    
+
                     setter_name = get_private_setter_name(ctx, name);
                     if (setter_name == JS_ATOM_NULL)
                         goto fail;
@@ -23120,7 +23417,7 @@
         } else if (prop_type == PROP_TYPE_IDENT && s->token.val != '(') {
             ClassFieldsDef *cf = &class_fields[is_static];
             JSAtom field_var_name = JS_ATOM_NULL;
-            
+
             /* class field */
 
             /* XXX: spec: not consistent with method name checks */
@@ -23128,7 +23425,7 @@
                 js_parse_error(s, "invalid field name");
                 goto fail;
             }
-            
+
             if (is_private) {
                 if (find_private_class_field(ctx, fd, name,
                                              fd->scope_level) >= 0) {
@@ -23178,7 +23475,7 @@
                 emit_atom(s, name);
                 emit_u16(s, s->cur_func->scope_level);
             }
-            
+
             if (s->token.val == '=') {
                 if (next_token(s))
                     goto fail;
@@ -23205,7 +23502,7 @@
         } else {
             JSParseFunctionEnum func_type;
             JSFunctionKindEnum func_kind;
-            
+
             func_type = JS_PARSE_FUNC_METHOD;
             func_kind = JS_FUNC_NORMAL;
             if (prop_type == PROP_TYPE_STAR) {
@@ -23297,7 +23594,7 @@
     {
         ClassFieldsDef *cf = &class_fields[0];
         int var_idx;
-        
+
         var_idx = define_var(s, fd, JS_ATOM_class_fields_init,
                              JS_VAR_DEF_CONST);
         if (var_idx < 0)
@@ -23324,7 +23621,7 @@
         emit_u16(s, 0);
         emit_op(s, OP_drop);
     }
-    
+
     if (class_name != JS_ATOM_NULL) {
         /* store the class name in the scoped class name variable (it
            is independent from the class statement variable
@@ -23374,6 +23671,8 @@
     return -1;
 }
 
+static BOOL is_label(JSParseState *s);
+
 static __exception int js_parse_array_literal(JSParseState *s)
 {
     uint32_t idx;
@@ -23383,6 +23682,17 @@
         return -1;
     /* small regular arrays are created on the stack */
     idx = 0;
+
+    JSValue tag = JS_UNINITIALIZED;
+
+    if (s->token.val == TOK_IDENT && is_label(s)) {
+      tag = JS_AtomToString(s->ctx, s->token.u.ident.atom);
+      if (next_token(s))
+        return -1;
+      if (next_token(s))
+        return -1;
+    }
+
     while (s->token.val != ']' && idx < 32) {
         if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS)
             break;
@@ -23497,6 +23807,12 @@
         emit_op(s, OP_drop);    /* array length - array */
     }
 done:
+    if (!JS_IsUninitialized(tag)) {
+      emit_push_const(s, tag, 0);
+      JS_FreeValue(s->ctx, tag);
+      emit_op(s, OP_define_field);
+      emit_atom(s, JS_ATOM_tag);
+    }
     return js_parse_expect(s, ']');
 }
 
@@ -23728,7 +24044,7 @@
     default:
         break;
     }
-    
+
     switch(opcode) {
     case OP_scope_get_var:  /* val -- */
         assert(special == PUT_LVALUE_NOKEEP ||
@@ -23782,7 +24098,7 @@
 {
     JSFunctionDef *fd = s->cur_func;
     JSVarDefEnum var_def_type;
-    
+
     if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {
         return js_parse_error(s, "yield is a reserved identifier");
     }
@@ -23893,7 +24209,7 @@
     JSAtom prop_name, var_name;
     int opcode, scope, tok1, skip_bits;
     BOOL has_initializer;
-    
+
     if (has_ellipsis < 0) {
         /* pre-parse destructuration target for spread detection */
         js_parse_skip_parens_token(s, &skip_bits, FALSE);
@@ -24214,6 +24530,8 @@
                         goto var_error;
                     opcode = OP_scope_get_var;
                     scope = s->cur_func->scope_level;
+                    label_lvalue = -1;
+                    depth_lvalue = 0;
                 } else {
                     if (js_parse_left_hand_side_expr(s))
                         return -1;
@@ -24326,13 +24644,17 @@
     emit_label(s, label_next);
 }
 
+#ifdef CONFIG_JSX
+#include "quickjs-jsx.h"
+#endif
+
 /* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */
 static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
 {
     FuncCallType call_type;
     int optional_chaining_label;
     BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;
-    
+
     call_type = FUNC_CALL_NORMAL;
     switch(s->token.val) {
     case TOK_NUMBER:
@@ -24388,7 +24710,7 @@
         if (next_token(s))
             return -1;
         break;
-        
+
     case TOK_DIV_ASSIGN:
         s->buf_ptr -= 2;
         goto parse_regexp;
@@ -24472,6 +24794,33 @@
             return -1;
         emit_op(s, OP_push_true);
         break;
+    case TOK___FILE__:
+      if (next_token(s))
+        return -1;
+      {
+        JSValue filename = JS_NewString(s->ctx, s->filename);
+        emit_push_const(s, filename, 0);
+        JS_FreeValue(s->ctx, filename);
+      }
+      break;
+    case TOK___DIR__:
+      if (next_token(s))
+        return -1;
+      {
+        int n = 0;
+        const char* pc = s->filename;
+        for (int i = 0; *pc; ++i, ++pc) {
+          if (*pc == '/') { n = i; }
+#ifdef _WIN32
+          else if (*pc == '\\') { n = i; }
+#endif // _WIN32
+          else if (*pc == '?' || *pc == '#') break;
+        }
+        JSValue dir = JS_NewStringLen(s->ctx, s->filename, n + 1);
+        emit_push_const(s, dir, 0);
+        JS_FreeValue(s->ctx, dir);
+      }
+      break;
     case TOK_IDENT:
         {
             JSAtom name;
@@ -24545,6 +24894,12 @@
             }
         }
         break;
+#ifdef CONFIG_JSX
+    case '<':
+        if (js_parse_jsx_expr(s,0))
+          return -1;
+        break;
+#endif
     case TOK_NEW:
         if (next_token(s))
             return -1;
@@ -24630,7 +24985,10 @@
     for(;;) {
         JSFunctionDef *fd = s->cur_func;
         BOOL has_optional_chain = FALSE;
-        
+#ifdef CONFIG_OBJECT_LITERAL_CALL
+        BOOL object_literal_call = FALSE;
+#endif
+
         if (s->token.val == TOK_QUESTION_MARK_DOT) {
             /* optional chaining */
             if (next_token(s))
@@ -24650,9 +25008,15 @@
             }
             call_type = FUNC_CALL_TEMPLATE;
             goto parse_func_call2;
-        } else if (s->token.val == '(' && accept_lparen) {
+        }
+#ifdef CONFIG_OBJECT_LITERAL_CALL
+        else if (s->token.val == '{' && (parse_flags & PF_ACCEPT_LCURLY)) {
+          object_literal_call = TRUE;
+          goto parse_func_call2;
+        }
+#endif
+        else if (s->token.val == '(' && accept_lparen) {
             int opcode, arg_count, drop_count;
-
             /* function call */
         parse_func_call:
             if (next_token(s))
@@ -24752,6 +25116,10 @@
                 arg_count++;
                 if (s->token.val == ')')
                     break;
+#ifdef CONFIG_OBJECT_LITERAL_CALL
+                if (object_literal_call)
+                  break; /* foo {bar:1} - "object literal call" */
+#endif
                 /* accept a trailing comma before the ')' */
                 if (js_parse_expect(s, ','))
                     return -1;
@@ -25113,8 +25481,12 @@
         parse_flags = 0;
         break;
     default:
-        if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC) |
-                                  PF_POSTFIX_CALL))
+        if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC)
+                                      | PF_POSTFIX_CALL
+#ifdef CONFIG_OBJECT_LITERAL_CALL
+                                      | PF_ACCEPT_LCURLY
+#endif
+        ))
             return -1;
         if (!s->got_lf &&
             (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
@@ -25127,7 +25499,7 @@
             put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
                        FALSE);
             if (next_token(s))
-                return -1;        
+                return -1;
         }
         break;
     }
@@ -25364,7 +25736,7 @@
 static __exception int js_parse_coalesce_expr(JSParseState *s, int parse_flags)
 {
     int label1;
-    
+
     if (js_parse_logical_and_or(s, TOK_LOR, parse_flags))
         return -1;
     if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {
@@ -25372,12 +25744,12 @@
         for(;;) {
             if (next_token(s))
                 return -1;
-            
+
             emit_op(s, OP_dup);
             emit_op(s, OP_is_undefined_or_null);
             emit_goto(s, OP_if_false, label1);
             emit_op(s, OP_drop);
-            
+
             if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
                 return -1;
             if (s->token.val != TOK_DOUBLE_QUESTION_MARK)
@@ -25428,7 +25800,7 @@
 
     if (s->token.val == TOK_YIELD) {
         BOOL is_star = FALSE, is_async;
-        
+
         if (!(s->cur_func->func_kind & JS_FUNC_GENERATOR))
             return js_parse_error(s, "unexpected 'yield' keyword");
         if (!s->cur_func->in_function_body)
@@ -25466,9 +25838,9 @@
                undefined) */
             emit_op(s, OP_drop);
             emit_op(s, OP_undefined);
-            
+
             emit_op(s, OP_undefined); /* initial value */
-            
+
             emit_label(s, label_loop);
             emit_op(s, OP_iterator_next);
             if (is_async)
@@ -25492,13 +25864,13 @@
             label_return = emit_goto(s, OP_if_true, -1);
             emit_op(s, OP_drop);
             emit_goto(s, OP_goto, label_loop);
-            
+
             emit_label(s, label_return);
             emit_op(s, OP_push_i32);
             emit_u32(s, 2);
             emit_op(s, OP_strict_eq);
             label_throw = emit_goto(s, OP_if_true, -1);
-            
+
             /* return handling */
             if (is_async)
                 emit_op(s, OP_await);
@@ -25514,13 +25886,13 @@
 
             emit_op(s, OP_get_field);
             emit_atom(s, JS_ATOM_value);
-            
+
             emit_label(s, label_return1);
             emit_op(s, OP_nip);
             emit_op(s, OP_nip);
             emit_op(s, OP_nip);
             emit_return(s, TRUE);
-            
+
             /* throw handling */
             emit_label(s, label_throw);
             emit_op(s, OP_iterator_call);
@@ -25545,7 +25917,7 @@
             emit_op(s, OP_throw_error);
             emit_atom(s, JS_ATOM_NULL);
             emit_u8(s, JS_THROW_ERROR_ITERATOR_THROW);
-            
+
             emit_label(s, label_next);
             emit_op(s, OP_get_field);
             emit_atom(s, JS_ATOM_value);
@@ -25555,7 +25927,7 @@
             emit_op(s, OP_nip);
         } else {
             int label_next;
-            
+
             if (is_async)
                 emit_op(s, OP_await);
             emit_op(s, OP_yield);
@@ -25610,7 +25982,7 @@
         put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
     } else if (op >= TOK_LAND_ASSIGN && op <= TOK_DOUBLE_QUESTION_MARK_ASSIGN) {
         int label, label1, depth_lvalue, label2;
-        
+
         if (next_token(s))
             return -1;
         if (get_lvalue(s, &opcode, &scope, &name, &label,
@@ -25623,7 +25995,7 @@
         label1 = emit_goto(s, op == TOK_LOR_ASSIGN ? OP_if_true : OP_if_false,
                            -1);
         emit_op(s, OP_drop);
-        
+
         if (js_parse_assign_expr2(s, parse_flags)) {
             JS_FreeAtom(s->ctx, name);
             return -1;
@@ -25632,7 +26004,7 @@
         if (opcode == OP_get_ref_value && name == name0) {
             set_object_name(s, name);
         }
-        
+
         switch(depth_lvalue) {
         case 1:
             emit_op(s, OP_insert2);
@@ -25652,7 +26024,7 @@
         put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_NOKEEP_DEPTH,
                    FALSE);
         label2 = emit_goto(s, OP_goto, -1);
-        
+
         emit_label(s, label1);
 
         /* remove the lvalue stack entries */
@@ -26870,7 +27242,7 @@
             emit_label(s, label_finally);
             if (s->token.val == TOK_FINALLY) {
                 int saved_eval_ret_idx = 0; /* avoid warning */
-                
+
                 if (next_token(s))
                     goto fail;
                 /* on the stack: ret_value gosub_ret_value */
@@ -26890,7 +27262,7 @@
                     emit_u16(s, saved_eval_ret_idx);
                     set_eval_ret_undefined(s);
                 }
-                
+
                 if (js_parse_block(s))
                     goto fail;
 
@@ -26995,7 +27367,7 @@
         if (js_parse_expect_semi(s))
             goto fail;
         break;
-        
+
     case TOK_ENUM:
     case TOK_EXPORT:
     case TOK_EXTENDS:
@@ -27312,7 +27684,7 @@
 {
     struct list_head *el;
     JSModuleDef *m;
-    
+
     /* first look at the loaded modules */
     list_for_each(el, &ctx->loaded_modules) {
         m = list_entry(el, JSModuleDef, link);
@@ -27377,7 +27749,7 @@
 {
     const char *base_cname, *cname;
     JSModuleDef *m;
-    
+
     base_cname = JS_AtomToCString(ctx, base_module_name);
     if (!base_cname)
         return NULL;
@@ -27915,7 +28287,7 @@
     BOOL is_c_module;
     int i;
     JSVarRef *var_ref;
-    
+
     if (m->func_created)
         return 0;
 
@@ -27939,7 +28311,7 @@
     m->func_created = TRUE;
 
     /* do it on the dependencies */
-    
+
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         if (js_create_module_function(ctx, rme->module) < 0)
@@ -27947,9 +28319,9 @@
     }
 
     return 0;
-}    
+}
+
 
-    
 /* Prepare a module to be executed by resolving all the imported
    variables. */
 static int js_link_module(JSContext *ctx, JSModuleDef *m)
@@ -27961,7 +28333,7 @@
     JSObject *p;
     BOOL is_c_module;
     JSValue ret_val;
-    
+
     if (m->instantiated)
         return 0;
     m->instantiated = TRUE;
@@ -28162,7 +28534,7 @@
 {
     JSAtom filename;
     JSModuleDef *m;
-    
+
     filename = JS_GetScriptOrModuleName(ctx, 0);
     if (filename == JS_ATOM_NULL)
         goto fail;
@@ -28185,11 +28557,11 @@
 {
     JSModuleDef *m;
     JSValue ret, func_obj;
-    
+
     m = js_host_resolve_imported_module(ctx, basename, filename);
     if (!m)
         return NULL;
-    
+
     if (js_resolve_module(ctx, m) < 0) {
         js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
         return NULL;
@@ -28204,6 +28576,28 @@
     return m;
 }
 
+JSValue JS_GetModuleExportItem(JSContext *ctx, JSModuleDef *m, JSAtom atom)
+{
+  JSValue rv = JS_UNDEFINED;
+  for (int n = 0; n < m->export_entries_count; ++n)
+  {
+    JSExportEntry *me = &m->export_entries[n];
+    if (me->local_name == atom && me->export_type == JS_EXPORT_TYPE_LOCAL /*???*/) {
+      rv = me->u.local.var_ref->value;
+      break;
+    }
+  }
+  return JS_DupValue(ctx, rv);
+}
+
+JSValue JS_GetModuleExportItemStr(JSContext *ctx, JSModuleDef *m, const char *name)
+{
+  JSAtom atom = JS_NewAtom(ctx, name);
+  JSValue rv = JS_GetModuleExportItem(ctx, m, atom);
+  JS_FreeAtom(ctx, atom);
+  return rv;
+}
+
 static JSValue js_dynamic_import_job(JSContext *ctx,
                                      int argc, JSValueConst *argv)
 {
@@ -28225,7 +28619,7 @@
     filename = JS_ToCString(ctx, specifier);
     if (!filename)
         goto exception;
-                     
+
     m = JS_RunModule(ctx, basename, filename);
     JS_FreeCString(ctx, filename);
     if (!m)
@@ -28267,7 +28661,7 @@
     JS_FreeAtom(ctx, basename);
     if (JS_IsException(basename_val))
         return basename_val;
-    
+
     promise = JS_NewPromiseCapability(ctx, resolving_funcs);
     if (JS_IsException(promise)) {
         JS_FreeValue(ctx, basename_val);
@@ -28278,7 +28672,7 @@
     args[1] = resolving_funcs[1];
     args[2] = basename_val;
     args[3] = specifier;
-    
+
     JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);
 
     JS_FreeValue(ctx, basename_val);
@@ -28688,7 +29082,7 @@
 {
     JSFunctionDef *fd = s->cur_func;
     int tok;
-    
+
     if (s->token.val == TOK_FUNCTION ||
         (token_is_pseudo_keyword(s, JS_ATOM_async) &&
          peek_token(s, TRUE) == TOK_FUNCTION)) {
@@ -28780,7 +29174,7 @@
     int pos, len, op;
     JSAtom atom;
     const JSOpCode *oi;
-    
+
     pos = 0;
     while (pos < bc_len) {
         op = bc_buf[pos];
@@ -28788,7 +29182,7 @@
             oi = &short_opcode_info(op);
         else
             oi = &opcode_info[op];
-            
+
         len = oi->size;
         switch(oi->fmt) {
         case OP_FMT_atom:
@@ -29571,7 +29965,7 @@
     update_label(s, *plabel_done, 1);
     s->jump_size++;
 }
-    
+
 /* return the position of the next opcode */
 static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                              JSAtom var_name, int scope_level, int op,
@@ -29777,7 +30171,7 @@
         is_arg_scope = (idx == ARG_SCOPE_END);
         if (var_idx >= 0)
             break;
-        
+
         if (!is_arg_scope) {
             var_idx = find_var(ctx, fd, var_name);
             if (var_idx >= 0)
@@ -29821,7 +30215,7 @@
             dbuf_put_u16(bc, idx);
             var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
         }
-        
+
         if (fd->is_eval)
             break; /* it it necessarily the top level function */
     }
@@ -30024,7 +30418,7 @@
 {
     /* if the field is not initialized, the error is catched when
        accessing it */
-    if (is_ref) 
+    if (is_ref)
         dbuf_putc(bc, OP_get_var_ref);
     else
         dbuf_putc(bc, OP_get_loc);
@@ -30039,7 +30433,7 @@
     int idx, var_kind;
     JSFunctionDef *fd;
     BOOL is_ref;
-    
+
     fd = s;
     is_ref = FALSE;
     for(;;) {
@@ -30365,7 +30759,7 @@
     int i, count;
     JSVarDef *vd;
     BOOL is_arg_scope;
-    
+
     count = b->arg_count + b->var_count + b->closure_var_count;
     s->closure_var = NULL;
     s->closure_var_count = 0;
@@ -30599,7 +30993,7 @@
        visible if there are cyclic module references */
     if (s->module) {
         label_next = new_label_fd(s, -1);
-        
+
         /* if 'this' is true, initialize the global variables and return */
         dbuf_putc(bc, OP_push_this);
         dbuf_putc(bc, OP_if_false);
@@ -30607,7 +31001,7 @@
         update_label(s, label_next, 1);
         s->jump_size++;
     }
-    
+
     /* add the global variables (only happens if s->is_global_var is
        true) */
     for(i = 0; i < s->global_var_count; i++) {
@@ -30636,7 +31030,7 @@
         }
         if (!has_closure) {
             int flags;
-            
+
             flags = 0;
             if (s->eval_type != JS_EVAL_TYPE_GLOBAL)
                 flags |= JS_PROP_CONFIGURABLE;
@@ -30644,11 +31038,11 @@
                 /* global function definitions need a specific handling */
                 dbuf_putc(bc, OP_fclosure);
                 dbuf_put_u32(bc, hf->cpool_idx);
-                
+
                 dbuf_putc(bc, OP_define_func);
                 dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
                 dbuf_putc(bc, flags);
-                
+
                 goto done_global_var;
             } else {
                 if (hf->is_lexical) {
@@ -30692,7 +31086,7 @@
 
     if (s->module) {
         dbuf_putc(bc, OP_return_undef);
-        
+
         dbuf_putc(bc, OP_label);
         dbuf_put_u32(bc, label_next);
         s->label_slots[label_next].pos2 = bc->size;
@@ -30797,7 +31191,7 @@
     for(i = 0; i < s->global_var_count; i++) {
         JSGlobalVar *hf = &s->global_vars[i];
         int flags;
-        
+
         /* check if global variable (XXX: simplify) */
         for(idx = 0; idx < s->closure_var_count; idx++) {
             JSClosureVar *cv = &s->closure_var[idx];
@@ -30819,7 +31213,7 @@
                 cv->var_name == JS_ATOM__arg_var_)
                 goto next;
         }
-        
+
         dbuf_putc(&bc_out, OP_check_define_var);
         dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
         flags = 0;
@@ -31098,7 +31492,7 @@
         case OP_set_class_name:
             /* only used during parsing */
             break;
-            
+
         default:
         no_change:
             dbuf_put(&bc_out, bc_buf + pos, len);
@@ -31447,11 +31841,19 @@
         pos_next = pos + len;
         switch(op) {
         case OP_line_num:
+
+            line_num = get_u32(bc_buf + pos + 1);
+#ifdef CONFIG_DEBUGGER
+            if (ctx->debugger_enabled) /* under the debugger */
+              goto no_change; /* emit OP_line_num BC for the debugger's "break on line functionality" */
+            else
+              break; /* remove OP_line_num from BCs */
+#else
             /* line number info (for debug). We put it in a separate
                compressed table to reduce memory usage and get better
                performance */
-            line_num = get_u32(bc_buf + pos + 1);
             break;
+#endif
 
         case OP_label:
             {
@@ -32659,7 +33061,7 @@
     b->realm = JS_DupContext(ctx);
 
     add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
-    
+
 #if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
     if (!(fd->js_mode & JS_MODE_STRIP)) {
         js_dump_function_bytecode(ctx, b);
@@ -32871,7 +33273,7 @@
 static JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s)
 {
     JSFunctionDef *fd;
-    
+
     fd = js_new_function_def(s->ctx, s->cur_func, FALSE, FALSE,
                              s->filename, 0);
     if (!fd)
@@ -32879,7 +33281,7 @@
     fd->func_name = JS_ATOM_NULL;
     fd->has_prototype = FALSE;
     fd->has_home_object = TRUE;
-    
+
     fd->has_arguments_binding = FALSE;
     fd->has_this_binding = TRUE;
     fd->is_derived_class_constructor = FALSE;
@@ -32887,7 +33289,7 @@
     fd->super_call_allowed = FALSE;
     fd->super_allowed = fd->has_home_object;
     fd->arguments_allowed = FALSE;
-    
+
     fd->func_kind = JS_FUNC_NORMAL;
     fd->func_type = JS_PARSE_FUNC_METHOD;
     return fd;
@@ -33063,7 +33465,7 @@
     if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
         emit_class_field_init(s);
     }
-    
+
     /* parse arguments */
     fd->has_simple_parameter_list = TRUE;
     fd->has_parameter_expressions = FALSE;
@@ -33098,7 +33500,7 @@
             if (push_scope(s) < 0)
                 return -1;
         }
-        
+
         while (s->token.val != ')') {
             JSAtom name;
             BOOL rest = FALSE;
@@ -33163,7 +33565,7 @@
                     has_opt_arg = TRUE;
                 } else if (s->token.val == '=') {
                     int label;
-                    
+
                     fd->has_simple_parameter_list = FALSE;
                     has_opt_arg = TRUE;
 
@@ -33246,7 +33648,7 @@
             }
             idx = vd->scope_next;
         }
-        
+
         /* the argument scope has no parent, hence we don't use pop_scope(s) */
         emit_op(s, OP_leave_scope);
         emit_u16(s, fd->scope_level);
@@ -33255,7 +33657,7 @@
         fd->scope_level = 0;
         fd->scope_first = fd->scopes[fd->scope_level].first;
     }
-    
+
     if (next_token(s))
         goto fail;
 
@@ -33369,7 +33771,7 @@
                     /* it is considered as defined at the top level
                        (needed for annex B.3.3.4 and B.3.3.5
                        checks) */
-                    hf->scope_level = 0; 
+                    hf->scope_level = 0;
                     hf->force_init = ((s->cur_func->js_mode & JS_MODE_STRICT) != 0);
                     /* store directly into global var, bypass lexical scope */
                     emit_op(s, OP_dup);
@@ -33497,16 +33899,16 @@
 
 static void js_parse_init(JSContext *ctx, JSParseState *s,
                           const char *input, size_t input_len,
-                          const char *filename)
+                          const char *filename, int line_no)
 {
     memset(s, 0, sizeof(*s));
     s->ctx = ctx;
     s->filename = filename;
-    s->line_num = 1;
+    s->line_num = line_no;
     s->buf_ptr = (const uint8_t *)input;
     s->buf_end = s->buf_ptr + input_len;
     s->token.val = ' ';
-    s->token.line_num = 1;
+    s->token.line_num = line_no;
 }
 
 static JSValue JS_EvalFunctionInternal(JSContext *ctx, JSValue fun_obj,
@@ -33575,7 +33977,7 @@
 /* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
 static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                  const char *input, size_t input_len,
-                                 const char *filename, int flags, int scope_idx)
+                                 const char *filename, int flags, int scope_idx, int line_no)
 {
     JSParseState s1, *s = &s1;
     int err, js_mode, eval_type;
@@ -33586,7 +33988,7 @@
     JSFunctionDef *fd;
     JSModuleDef *m;
 
-    js_parse_init(ctx, s, input, input_len, filename);
+    js_parse_init(ctx, s, input, input_len, filename, line_no);
     skip_shebang(s);
 
     eval_type = flags & JS_EVAL_TYPE_MASK;
@@ -33650,7 +34052,7 @@
 
     push_scope(s); /* body scope */
     fd->body_scope = fd->scope_level;
-    
+
     err = js_parse_program(s);
     if (err) {
     fail:
@@ -33686,13 +34088,13 @@
 /* the indirection is needed to make 'eval' optional */
 static JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                const char *input, size_t input_len,
-                               const char *filename, int flags, int scope_idx)
+                               const char *filename, int flags, int scope_idx, int line_no)
 {
     if (unlikely(!ctx->eval_internal)) {
         return JS_ThrowTypeError(ctx, "eval is not supported");
     }
     return ctx->eval_internal(ctx, this_obj, input, input_len, filename,
-                              flags, scope_idx);
+                              flags, scope_idx, line_no);
 }
 
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
@@ -33707,7 +34109,7 @@
     str = JS_ToCStringLen(ctx, &len, val);
     if (!str)
         return JS_EXCEPTION;
-    ret = JS_EvalInternal(ctx, this_obj, str, len, "<input>", flags, scope_idx);
+    ret = JS_EvalInternal(ctx, this_obj, str, len, "<input>", flags, scope_idx, 1);
     JS_FreeCString(ctx, str);
     return ret;
 
@@ -33723,17 +34125,37 @@
     assert(eval_type == JS_EVAL_TYPE_GLOBAL ||
            eval_type == JS_EVAL_TYPE_MODULE);
     ret = JS_EvalInternal(ctx, this_obj, input, input_len, filename,
-                          eval_flags, -1);
+                          eval_flags, -1, 1);
     return ret;
 }
 
 JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
                 const char *filename, int eval_flags)
 {
-    return JS_EvalThis(ctx, ctx->global_obj, input, input_len, filename,
-                       eval_flags);
+    int eval_type = eval_flags & JS_EVAL_TYPE_MASK;
+    JSValue ret;
+
+    assert(eval_type == JS_EVAL_TYPE_GLOBAL ||
+           eval_type == JS_EVAL_TYPE_MODULE);
+    ret = JS_EvalInternal(ctx, ctx->global_obj, input, input_len, filename,
+                          eval_flags, -1, 1);
+    return ret;
 }
 
+JSValue JS_Eval2(JSContext *ctx, const char *input, size_t input_len,
+  const char *filename, int eval_flags, int line_no)
+{
+  int eval_type = eval_flags & JS_EVAL_TYPE_MASK;
+  JSValue ret;
+
+  assert(eval_type == JS_EVAL_TYPE_GLOBAL ||
+    eval_type == JS_EVAL_TYPE_MODULE);
+  ret = JS_EvalInternal(ctx, ctx->global_obj, input, input_len, filename,
+    eval_flags, -1, line_no);
+  return ret;
+}
+
+
 int JS_ResolveModule(JSContext *ctx, JSValueConst obj)
 {
     if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
@@ -33785,13 +34207,13 @@
     js_free(ctx, s->hash_table);
     s->hash_table = new_hash_table;
     s->hash_size = new_hash_size;
-    
+
     for(i = 0; i < s->hash_size; i++) {
         s->hash_table[i] = -1;
     }
     for(i = 0; i < s->object_count; i++) {
         e = &s->object_tab[i];
-        h = js_object_list_get_hash(e->obj, s->hash_size); 
+        h = js_object_list_get_hash(e->obj, s->hash_size);
         e->hash_next = s->hash_table[h];
         s->hash_table[h] = i;
     }
@@ -33804,7 +34226,7 @@
 {
     JSObjectListEntry *e;
     uint32_t h, new_hash_size;
-    
+
     if (js_resize_array(ctx, (void *)&s->object_tab,
                         sizeof(s->object_tab[0]),
                         &s->object_size, s->object_count + 1))
@@ -33817,7 +34239,7 @@
             return -1;
     }
     e = &s->object_tab[s->object_count++];
-    h = js_object_list_get_hash(obj, s->hash_size); 
+    h = js_object_list_get_hash(obj, s->hash_size);
     e->obj = obj;
     e->hash_next = s->hash_table[h];
     s->hash_table[h] = s->object_count - 1;
@@ -33833,7 +34255,7 @@
     /* must test empty size because there is no hash table */
     if (s->object_count == 0)
         return -1;
-    h = js_object_list_get_hash(obj, s->hash_size); 
+    h = js_object_list_get_hash(obj, s->hash_size);
     p = s->hash_table[h];
     while (p != -1) {
         e = &s->object_tab[p];
@@ -34237,7 +34659,7 @@
             int bpos, d;
             uint8_t v8;
             size_t i0;
-            
+
             /* little endian BCD */
             i = 0;
             while (i < a->len && a->tab[i] == 0)
@@ -34257,7 +34679,7 @@
                 return -1;
             }
             bc_put_leb128(s, len);
-            
+
             bpos = 0;
             v8 = 0;
             i0 = i;
@@ -34295,7 +34717,7 @@
     JSFunctionBytecode *b = JS_VALUE_GET_PTR(obj);
     uint32_t flags;
     int idx, i;
-    
+
     bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
     flags = idx = 0;
     bc_set_flags(&flags, &idx, b->has_prototype, 1);
@@ -34313,7 +34735,7 @@
     bc_put_u16(s, flags);
     bc_put_u8(s, b->js_mode);
     bc_put_atom(s, b->func_name);
-    
+
     bc_put_leb128(s, b->arg_count);
     bc_put_leb128(s, b->var_count);
     bc_put_leb128(s, b->defined_arg_count);
@@ -34340,7 +34762,7 @@
     } else {
         bc_put_leb128(s, 0);
     }
-    
+
     for(i = 0; i < b->closure_var_count; i++) {
         JSClosureVar *cv = &b->closure_var[i];
         bc_put_atom(s, cv->var_name);
@@ -34354,17 +34776,17 @@
         assert(idx <= 8);
         bc_put_u8(s, flags);
     }
-    
+
     if (JS_WriteFunctionBytecode(s, b->byte_code_buf, b->byte_code_len))
         goto fail;
-    
+
     if (b->has_debug) {
         bc_put_atom(s, b->debug.filename);
         bc_put_leb128(s, b->debug.line_num);
         bc_put_leb128(s, b->debug.pc2line_len);
         dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
     }
-    
+
     for(i = 0; i < b->cpool_count; i++) {
         if (JS_WriteObjectRec(s, b->cpool[i]))
             goto fail;
@@ -34378,16 +34800,16 @@
 {
     JSModuleDef *m = JS_VALUE_GET_PTR(obj);
     int i;
-    
+
     bc_put_u8(s, BC_TAG_MODULE);
     bc_put_atom(s, m->module_name);
-    
+
     bc_put_leb128(s, m->req_module_entries_count);
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         bc_put_atom(s, rme->module_name);
     }
-    
+
     bc_put_leb128(s, m->export_entries_count);
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
@@ -34400,13 +34822,13 @@
         }
         bc_put_atom(s, me->export_name);
     }
-    
+
     bc_put_leb128(s, m->star_export_entries_count);
     for(i = 0; i < m->star_export_entries_count; i++) {
         JSStarExportEntry *se = &m->star_export_entries[i];
         bc_put_leb128(s, se->req_module_idx);
     }
-    
+
     bc_put_leb128(s, m->import_entries_count);
     for(i = 0; i < m->import_entries_count; i++) {
         JSImportEntry *mi = &m->import_entries[i];
@@ -34414,7 +34836,7 @@
         bc_put_atom(s, mi->import_name);
         bc_put_leb128(s, mi->req_module_idx);
     }
-    
+
     if (JS_WriteObjectRec(s, m->func_obj))
         goto fail;
     return 0;
@@ -34429,7 +34851,7 @@
     JSValue val;
     int ret;
     BOOL is_template;
-    
+
     if (s->allow_bytecode && !p->extensible) {
         /* not extensible array: we consider it is a
            template when we are saving bytecode */
@@ -34603,7 +35025,7 @@
         {
             JSObject *p = JS_VALUE_GET_OBJ(obj);
             int ret, idx;
-            
+
             if (s->allow_reference) {
                 idx = js_object_list_find(s->ctx, &s->object_list, p);
                 if (idx >= 0) {
@@ -34744,7 +35166,7 @@
         s->first_atom = 1;
     js_dbuf_init(ctx, &s->dbuf);
     js_object_list_init(&s->object_list);
-    
+
     if (JS_WriteObjectRec(s, obj))
         goto fail;
     if (JS_WriteObjectAtoms(s))
@@ -34792,7 +35214,7 @@
     JSObject **objects;
     int objects_count;
     int objects_size;
-    
+
 #ifdef DUMP_READ_OBJECT
     const uint8_t *ptr_last;
     int level;
@@ -34800,7 +35222,7 @@
 } BCReaderState;
 
 #ifdef DUMP_READ_OBJECT
-static void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
+static void __js_printf_like(2,3) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
     va_list ap;
     int i, n, n0;
 
@@ -35077,7 +35499,7 @@
     limb_t v;
     bf_t *a;
     int bpos, d;
-    
+
     p = js_new_bf(s->ctx);
     if (!p)
         goto fail;
@@ -35289,7 +35711,7 @@
     b = js_mallocz(ctx, function_size);
     if (!b)
         return JS_EXCEPTION;
-            
+
     memcpy(b, &bc, offsetof(JSFunctionBytecode, debug));
     b->header.ref_count = 1;
     if (local_count != 0) {
@@ -35301,9 +35723,9 @@
     if (b->cpool_count != 0) {
         b->cpool = (void *)((uint8_t*)b + cpool_offset);
     }
-    
+
     add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
-            
+
     obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
 
 #ifdef DUMP_READ_OBJECT
@@ -35416,7 +35838,7 @@
     JSAtom module_name;
     int i;
     uint8_t v8;
-    
+
     if (bc_get_atom(s, &module_name))
         goto fail;
 #ifdef DUMP_READ_OBJECT
@@ -35517,7 +35939,7 @@
     JSAtom atom;
     JSValue val;
     int ret;
-    
+
     obj = JS_NewObject(ctx);
     if (BC_add_object_ref(s, obj))
         goto fail;
@@ -35597,7 +36019,7 @@
     uint8_t array_tag;
     JSValueConst args[3];
     uint32_t offset, len, idx;
-    
+
     if (bc_get_u8(s, &array_tag))
         return JS_EXCEPTION;
     if (array_tag >= JS_TYPED_ARRAY_COUNT)
@@ -35642,7 +36064,7 @@
     JSContext *ctx = s->ctx;
     uint32_t byte_length;
     JSValue obj;
-    
+
     if (bc_get_leb128(s, &byte_length))
         return JS_EXCEPTION;
     if (unlikely(s->buf_end - s->ptr < byte_length)) {
@@ -35668,7 +36090,7 @@
     uint8_t *data_ptr;
     JSValue obj;
     uint64_t u64;
-    
+
     if (bc_get_leb128(s, &byte_length))
         return JS_EXCEPTION;
     if (bc_get_u64(s, &u64))
@@ -35715,6 +36137,13 @@
     return JS_EXCEPTION;
 }
 
+JSValue JS_NewDate(JSContext* ctx, double ms_1970) {
+  JSValue obj = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_DATE], JS_CLASS_DATE);
+  if (!JS_IsException(obj))
+    JS_SetObjectData(ctx, obj, JS_NewFloat64(ctx,ms_1970));
+  return obj;
+}
+
 static JSValue JS_ReadObjectValue(BCReaderState *s)
 {
     JSContext *ctx = s->ctx;
@@ -35906,8 +36335,8 @@
     js_free(s->ctx, s->objects);
 }
 
-JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
-                       int flags)
+JSValue JS_ReadObject2(JSContext *ctx, const uint8_t *buf, size_t buf_len,
+                       int flags, size_t* premnants_len)
 {
     BCReaderState ss, *s = &ss;
     JSValue obj;
@@ -35933,10 +36362,19 @@
     } else {
         obj = JS_ReadObjectRec(s);
     }
+    *premnants_len = s->buf_end - s->ptr;
     bc_reader_free(s);
     return obj;
 }
 
+JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
+  int flags)
+{
+  size_t dummy;
+  return JS_ReadObject2(ctx, buf, buf_len, flags, &dummy);
+}
+
+
 /*******************************************************************/
 /* runtime functions & objects */
 
@@ -36178,7 +36616,7 @@
     set_cycle_flag(ctx, proto);
 }
 
-void JS_SetConstructor(JSContext *ctx, JSValueConst func_obj, 
+void JS_SetConstructor(JSContext *ctx, JSValueConst func_obj,
                        JSValueConst proto)
 {
     JS_SetConstructor2(ctx, func_obj, proto,
@@ -37021,7 +37459,7 @@
     if (!res) {
         return JS_ThrowTypeError(ctx, "proxy preventExtensions handler returned false");
     }
-    
+
     p = JS_VALUE_GET_OBJ(obj);
     flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;
     if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
@@ -37062,7 +37500,7 @@
     JSPropertyEnum *props;
     uint32_t len, i;
     int flags, res;
-    
+
     if (!JS_IsObject(obj))
         return JS_TRUE;
 
@@ -37091,7 +37529,7 @@
     if (res < 0)
         return JS_EXCEPTION;
     res ^= 1;
-done:        
+done:
     js_free_prop_enum(ctx, props, len);
     return JS_NewBool(ctx, res);
 
@@ -37114,14 +37552,14 @@
     obj = JS_NewObject(ctx);
     if (JS_IsException(obj))
         return obj;
-    
+
     iter = JS_GetIterator(ctx, iterable, FALSE);
     if (JS_IsException(iter))
         goto fail;
     next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
     if (JS_IsException(next_method))
         goto fail;
-    
+
     for(;;) {
         JSValue key, value, item;
         item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
@@ -37131,7 +37569,7 @@
             JS_FreeValue(ctx, item);
             break;
         }
-        
+
         key = JS_UNDEFINED;
         value = JS_UNDEFINED;
         if (!JS_IsObject(item)) {
@@ -37516,7 +37954,7 @@
 
     string_buffer_init(ctx, b, 0);
     string_buffer_putc8(b, '(');
-    
+
     if (func_kind == JS_FUNC_ASYNC || func_kind == JS_FUNC_ASYNC_GENERATOR) {
         string_buffer_puts8(b, "async ");
     }
@@ -37600,6 +38038,12 @@
     return JS_ToLengthFree(ctx, pres, len_val);
 }
 
+int JS_GetPropertyLength(JSContext *ctx, int64_t *pres, JSValueConst obj)
+{
+  return js_get_length64(ctx, pres, obj);
+}
+
+
 static void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len)
 {
     uint32_t i;
@@ -37849,7 +38293,7 @@
     JSValue v, r = JS_UNDEFINED;
     int64_t k;
     BOOL done;
-    
+
     iter = JS_GetIterator(ctx, items, FALSE);
     if (JS_IsException(iter))
         goto exception;
@@ -37895,7 +38339,7 @@
     if (!JS_IsObject(proto)) {
         JSContext *realm;
         JSValueConst proto1;
-        
+
         JS_FreeValue(ctx, proto);
         realm = JS_GetFunctionRealm(ctx, new_target);
         if (!realm)
@@ -37983,7 +38427,7 @@
                                               JSValueConst errors)
 {
     JSValue obj;
-    
+
     obj = JS_NewObjectProtoClass(ctx,
                                  ctx->native_error_proto[JS_AGGREGATE_ERROR],
                                  JS_CLASS_ERROR);
@@ -38049,7 +38493,7 @@
             fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &val);
             if (fromPresent < 0)
                 goto exception;
-            
+
             if (fromPresent) {
                 if (JS_SetPropertyInt64(ctx, obj, to, val) < 0)
                     goto exception;
@@ -38245,6 +38689,18 @@
         return JS_NewBool(ctx, ret);
 }
 
+static JSValue js_array_isTuple(JSContext *ctx, JSValueConst this_val,
+                                int argc, JSValueConst *argv)
+{
+    /* isArray and has tag property */
+    int ret;
+    ret = JS_IsTuple(ctx, argv[0]);
+    if (ret < 0)
+        return JS_EXCEPTION;
+    else
+        return JS_NewBool(ctx, ret);
+}
+
 static JSValue js_get_this(JSContext *ctx,
                            JSValueConst this_val)
 {
@@ -38257,7 +38713,7 @@
     JSValue ctor, ret, species;
     int res;
     JSContext *realm;
-    
+
     res = JS_IsArray(ctx, obj);
     if (res < 0)
         return JS_EXCEPTION;
@@ -38299,6 +38755,7 @@
 
 static const JSCFunctionListEntry js_array_funcs[] = {
     JS_CFUNC_DEF("isArray", 1, js_array_isArray ),
+    JS_CFUNC_DEF("isTuple", 1, js_array_isTuple),
     JS_CFUNC_DEF("from", 1, js_array_from ),
     JS_CFUNC_DEF("of", 0, js_array_of ),
     JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
@@ -38422,7 +38879,7 @@
     this_arg = JS_UNDEFINED;
     if (argc > 1)
         this_arg = argv[1];
-        
+
     if (check_function(ctx, func))
         goto exception;
 
@@ -38966,9 +39423,12 @@
     JSValue *arrp;
     uint32_t count32;
 
+    MARK_MODIFIED_VALUE(this_val);
+
     obj = JS_ToObject(ctx, this_val);
     if (js_get_length64(ctx, &len, obj))
         goto exception;
+
     newLen = 0;
     if (len > 0) {
         newLen = len - 1;
@@ -39019,6 +39479,46 @@
     int64_t len, from, newLen;
 
     obj = JS_ToObject(ctx, this_val);
+
+    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
+        JSObject *p = JS_VALUE_GET_OBJ(obj);
+
+        MARK_MODIFIED_OBJ(p);
+
+        if (p->class_id != JS_CLASS_ARRAY ||
+            !p->fast_array || !p->extensible)
+            goto generic_case;
+        /* length must be writable */
+        if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE)))
+            goto generic_case;
+        /* check the length */
+        if (unlikely(JS_VALUE_GET_TAG(p->prop[0].u.value) != JS_TAG_INT))
+            goto generic_case;
+        len = JS_VALUE_GET_INT(p->prop[0].u.value);
+        /* we don't support holes */
+        if (unlikely(len != p->u.array.count))
+            goto generic_case;
+        newLen = len + argc;
+        if (unlikely(newLen > INT32_MAX))
+            goto generic_case;
+        if (newLen > p->u.array.u1.size) {
+            if (expand_fast_array(ctx, p, newLen))
+                goto exception;
+        }
+        if (unshift && argc > 0) {
+            memmove(p->u.array.u.values + argc, p->u.array.u.values,
+                    len * sizeof(p->u.array.u.values[0]));
+            from = 0;
+        } else {
+            from = len;
+        }
+        for(i = 0; i < argc; i++) {
+            p->u.array.u.values[from + i] = JS_DupValue(ctx, argv[i]);
+        }
+        p->u.array.count = newLen;
+        p->prop[0].u.value = JS_NewInt32(ctx, newLen);
+    } else {
+    generic_case:
     if (js_get_length64(ctx, &len, obj))
         goto exception;
     newLen = len + argc;
@@ -39039,7 +39539,7 @@
     }
     if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)
         goto exception;
-
+    }
     JS_FreeValue(ctx, obj);
     return JS_NewInt64(ctx, newLen);
 
@@ -39057,6 +39557,8 @@
     int l_present, h_present;
     uint32_t count32;
 
+    MARK_MODIFIED_VALUE(this_val);
+
     lval = JS_UNDEFINED;
     obj = JS_ToObject(ctx, this_val);
     if (js_get_length64(ctx, &len, obj))
@@ -39135,6 +39637,7 @@
         goto exception;
 
     if (splice) {
+        MARK_MODIFIED_VALUE(obj);
         if (argc == 0) {
             item_count = 0;
             del_count = 0;
@@ -39230,6 +39733,8 @@
     JSValue obj;
     int64_t len, from, to, final, count;
 
+    MARK_MODIFIED_VALUE(this_val);
+
     obj = JS_ToObject(ctx, this_val);
     if (js_get_length64(ctx, &len, obj))
         goto exception;
@@ -39451,6 +39956,8 @@
     int64_t i, len, undefined_count = 0;
     int present;
 
+    MARK_MODIFIED_VALUE(this_val);
+
     if (!JS_IsUndefined(asc.method)) {
         if (check_function(ctx, asc.method))
             goto exception;
@@ -40121,7 +40628,7 @@
     uint32_t idx;
     JSObject *p;
     JSString *p1, *p2;
-    
+
     if (__JS_AtomIsTaggedInt(prop)) {
         idx = __JS_AtomToUInt32(prop);
         p = JS_VALUE_GET_OBJ(this_obj);
@@ -40287,7 +40794,7 @@
         goto exception;
     if (js_get_length64(ctx, &n, raw) < 0)
         goto exception;
-        
+
     for (i = 0; i < n; i++) {
         val = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, raw, i));
         if (JS_IsException(val))
@@ -40640,7 +41147,7 @@
 {
     int ret;
     JSValue flags;
-    
+
     ret = js_is_regexp(ctx, regexp);
     if (ret < 0)
         return -1;
@@ -40914,7 +41421,7 @@
         }
         if (JS_IsException(repl_str))
             goto exception;
-        
+
         string_buffer_concat(b, sp, endOfLastMatch, pos);
         string_buffer_concat_value_free(b, repl_str);
         endOfLastMatch = pos + searchp->len;
@@ -41592,7 +42099,7 @@
     static struct { const char *tag, *attr; } const defs[] = {
         { "a", "name" }, { "big", NULL }, { "blink", NULL }, { "b", NULL },
         { "tt", NULL }, { "font", "color" }, { "font", "size" }, { "i", NULL },
-        { "a", "href" }, { "small", NULL }, { "strike", NULL }, 
+        { "a", "href" }, { "small", NULL }, { "strike", NULL },
         { "sub", NULL }, { "sup", NULL },
     };
 
@@ -41759,7 +42266,7 @@
     uint32_t tag;
 
     if (unlikely(argc == 0)) {
-        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+        return __JS_NewFloat64(ctx, is_max ? -INFINITY : INFINITY);
     }
 
     tag = JS_VALUE_GET_TAG(argv[0]);
@@ -41931,12 +42438,15 @@
     return __JS_NewFloat64(ctx, u.d - 1.0);
 }
 
+static double js_math_floor(double x) { return floor(x); }
+static double js_math_ceil(double x) { return ceil(x); }
+
 static const JSCFunctionListEntry js_math_funcs[] = {
     JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
     JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
     JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
-    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
-    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
+    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, js_math_floor),
+    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, js_math_ceil ),
     JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
     JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
 
@@ -42010,12 +42520,28 @@
     return JS_NewInt64(ctx, d);
 }
 
+//for windows platform
+#ifdef _WIN32
+#include <timezoneapi.h>
+#endif
+
 /* OS dependent. d = argv[0] is in ms from 1970. Return the difference
    between UTC time and local time 'd' in minutes */
 static int getTimezoneOffset(int64_t time) {
 #if defined(_WIN32)
-    /* XXX: TODO */
-    return 0;
+    TIME_ZONE_INFORMATION tzi;
+    memset(&tzi, 0, sizeof(tzi));
+    DWORD ctz = GetTimeZoneInformation(&tzi);
+    int r = tzi.Bias; // in minutes
+    switch (ctz) {
+        case TIME_ZONE_ID_STANDARD:
+        r += tzi.StandardBias;
+        break;
+        case TIME_ZONE_ID_DAYLIGHT:
+        r += tzi.DaylightBias;
+        break;
+    }
+    return r;
 #else
     time_t ti;
     struct tm tm;
@@ -42392,7 +42918,7 @@
     if (p->len == 0) {
     empty_regex:
         return JS_NewString(ctx, "(?:)");
-    }    
+    }
     string_buffer_init2(ctx, b, p->len, p->is_wide_char);
 
     /* Escape '/' and newline sequences as needed */
@@ -42451,7 +42977,7 @@
         else
             return JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);
     }
-    
+
     flags = lre_get_flags(re->bytecode->u.str8);
     return JS_NewBool(ctx, (flags & mask) != 0);
 }
@@ -42978,7 +43504,7 @@
     JSString *strp;
     int64_t lastIndex;
     JSRegExpStringIteratorData *it;
-    
+
     if (!JS_IsObject(R))
         return JS_ThrowTypeErrorNotAnObject(ctx);
 
@@ -42986,7 +43512,7 @@
     flags = JS_UNDEFINED;
     matcher = JS_UNDEFINED;
     iter = JS_UNDEFINED;
-    
+
     S = JS_ToString(ctx, argv[0]);
     if (JS_IsException(S))
         goto exception;
@@ -43007,7 +43533,7 @@
     if (JS_SetProperty(ctx, matcher, JS_ATOM_lastIndex,
                        JS_NewInt64(ctx, lastIndex)) < 0)
         goto exception;
-    
+
     iter = JS_NewObjectClass(ctx, JS_CLASS_REGEXP_STRING_ITERATOR);
     if (JS_IsException(iter))
         goto exception;
@@ -43145,7 +43671,7 @@
     str = JS_ToString(ctx, argv[0]);
     if (JS_IsException(str))
         goto exception;
-        
+
     sp = JS_VALUE_GET_STRING(str);
     rp = NULL;
     functionalReplace = JS_IsFunction(ctx, rep);
@@ -43424,7 +43950,7 @@
     while (q < size) {
         if (JS_SetProperty(ctx, splitter, JS_ATOM_lastIndex, JS_NewInt32(ctx, q)) < 0)
             goto exception;
-        JS_FreeValue(ctx, z);    
+        JS_FreeValue(ctx, z);
         z = JS_RegExpExec(ctx, splitter, str);
         if (JS_IsException(z))
             goto exception;
@@ -43479,7 +44005,7 @@
     JS_FreeValue(ctx, ctor);
     JS_FreeValue(ctx, splitter);
     JS_FreeValue(ctx, flags);
-    JS_FreeValue(ctx, z);    
+    JS_FreeValue(ctx, z);
     return A;
 }
 
@@ -43564,7 +44090,7 @@
         {
             JSValue prop_val;
             JSAtom prop_name;
-            
+
             if (json_next_token(s))
                 goto fail;
             val = JS_NewObject(ctx);
@@ -43686,7 +44212,7 @@
     JSParseState s1, *s = &s1;
     JSValue val = JS_UNDEFINED;
 
-    js_parse_init(ctx, s, buf, buf_len, filename);
+    js_parse_init(ctx, s, buf, buf_len, filename, 1);
     s->ext_json = ((flags & JS_PARSE_JSON_EXT) != 0);
     if (json_next_token(s))
         goto fail;
@@ -43707,7 +44233,7 @@
 JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
                      const char *filename)
 {
-    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0); 
+    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0);
 }
 
 static JSValue internalize_json_property(JSContext *ctx, JSValueConst holder,
@@ -43900,7 +44426,7 @@
     int64_t i, len;
     int cl, ret;
     BOOL has_content;
-    
+
     indent1 = JS_UNDEFINED;
     sep = JS_UNDEFINED;
     sep1 = JS_UNDEFINED;
@@ -44075,7 +44601,7 @@
         JS_FreeValue(ctx, val);
         return 0;
     }
-    
+
 exception:
     JS_FreeValue(ctx, val);
     JS_FreeValue(ctx, tab);
@@ -44193,7 +44719,7 @@
                                JS_DupValue(ctx, obj), JS_PROP_C_W_E) < 0)
         goto exception;
     val = JS_DupValue(ctx, obj);
-                           
+
     val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);
     if (JS_IsException(val))
         goto exception;
@@ -44449,7 +44975,7 @@
         JS_ThrowStackOverflow(ctx);
         return NULL;
     }
-    
+
     /* 's' should never be NULL */
     if (s->is_revoked) {
         JS_ThrowTypeErrorRevokedProxy(ctx);
@@ -44848,7 +45374,7 @@
         JS_FreeValue(ctx, trap_result_obj);
         if (res < 0)
             return -1;
-        
+
         if (target_desc_ret) {
             /* convert result_desc.flags to defineProperty flags */
             flags1 = result_desc.flags | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE;
@@ -45213,7 +45739,7 @@
 
     if (flags & JS_CALL_FLAG_CONSTRUCTOR)
         return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);
-    
+
     s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);
     if (!s)
         return JS_EXCEPTION;
@@ -45798,7 +46324,7 @@
 {
     JSMapRecord *mr, *mr_next;
     JSMapState *s;
-    
+
     /* first pass to remove the records from the WeakMap/WeakSet
        lists */
     for(mr = p->first_weak_ref; mr != NULL; mr = mr->next_weak_ref) {
@@ -45808,7 +46334,7 @@
         list_del(&mr->hash_link);
         list_del(&mr->link);
     }
-    
+
     /* second pass to free the values to avoid modifying the weak
        reference list while traversing it. */
     for(mr = p->first_weak_ref; mr != NULL; mr = mr_next) {
@@ -46807,7 +47333,7 @@
     JSValueConst resolve_element_env = func_data[4];
     JSValue ret, obj;
     int is_zero, index;
-    
+
     if (JS_ToInt32(ctx, &index, func_data[1]))
         return JS_EXCEPTION;
     if (alreadyCalled)
@@ -46816,7 +47342,7 @@
 
     if (resolve_type == PROMISE_MAGIC_allSettled) {
         JSValue str;
-        
+
         obj = JS_NewObject(ctx);
         if (JS_IsException(obj))
             return JS_EXCEPTION;
@@ -46841,7 +47367,7 @@
     if (JS_DefinePropertyValueUint32(ctx, values, index,
                                      obj, JS_PROP_C_W_E) < 0)
         return JS_EXCEPTION;
-    
+
     is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
     if (is_zero < 0)
         return JS_EXCEPTION;
@@ -46874,7 +47400,7 @@
     JSValueConst then_args[2], resolve_element_data[5];
     BOOL done;
     int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);
-    
+
     if (!JS_IsObject(this_val))
         return JS_ThrowTypeErrorNotAnObject(ctx);
     result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
@@ -46910,7 +47436,7 @@
                                          JS_NewInt32(ctx, 1),
                                          JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
             goto fail_reject;
-        
+
         index = 0;
         for(;;) {
             /* XXX: conformance: should close the iterator if error on 'done'
@@ -46920,7 +47446,7 @@
                 goto fail_reject;
             if (done)
                 break;
-            next_promise = JS_Call(ctx, promise_resolve, 
+            next_promise = JS_Call(ctx, promise_resolve,
                                    this_val, 1, (JSValueConst *)&item);
             JS_FreeValue(ctx, item);
             if (JS_IsException(next_promise)) {
@@ -46940,7 +47466,7 @@
                 JS_FreeValue(ctx, next_promise);
                 goto fail_reject1;
             }
-            
+
             if (magic == PROMISE_MAGIC_allSettled) {
                 reject_element =
                     JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
@@ -47593,7 +48119,7 @@
     return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
 }
 
-static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
+static int __js_printf_like(2,3) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
 {
     va_list ap;
 
@@ -47866,7 +48392,7 @@
     JS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1 ),
     JS_CFUNC_DEF("escape", 1, js_global_escape ),
     JS_CFUNC_DEF("unescape", 1, js_global_unescape ),
-    JS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0 ),
+    JS_PROP_DOUBLE_DEF("Infinity", INFINITY, 0 ),
     JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
     JS_PROP_UNDEFINED_DEF("undefined", 0 ),
 
@@ -47894,7 +48420,7 @@
 static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv);
 
-static __exception int JS_ThisTimeValue(JSContext *ctx, double *valp, JSValueConst this_val)
+__exception int JS_ThisTimeValue(JSContext *ctx, double *valp, JSValueConst this_val)
 {
     if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
         JSObject *p = JS_VALUE_GET_OBJ(this_val);
@@ -48020,7 +48546,7 @@
     int64_t y;
     double days, d, h, m1;
     int i, m, md;
-    
+
     m1 = fields[1];
     m = fmod(m1, 12);
     if (m < 0)
@@ -48035,7 +48561,7 @@
         days += md;
     }
     days += fields[2] - 1;
-    h = fields[3] * 3600000 + fields[4] * 60000 + 
+    h = fields[3] * 3600000 + fields[4] * 60000 +
         fields[5] * 1000 + fields[6];
     d = days * 86400000 + h;
     if (is_local)
@@ -48333,7 +48859,7 @@
 static int string_get_digits(JSString *sp, int *pp, int64_t *pval) {
     int64_t v = 0;
     int c, p = *pp, p_start;
-    
+
     if (p >= sp->len)
         return -1;
     p_start = p;
@@ -48355,14 +48881,14 @@
 
 static int string_get_signed_digits(JSString *sp, int *pp, int64_t *pval) {
     int res, sgn, p = *pp;
-    
+
     if (p >= sp->len)
         return -1;
 
     sgn = string_get(sp, p);
     if (sgn == '-' || sgn == '+')
         p++;
- 
+
     res = string_get_digits(sp, &p, pval);
     if (res == 0 && sgn == '-')
         *pval = -*pval;
@@ -48456,13 +48982,13 @@
     int p, i, c, sgn, l;
     JSString *sp;
     BOOL is_local;
-    
+
     rv = JS_NAN;
 
     s = JS_ToString(ctx, argv[0]);
     if (JS_IsException(s))
         return JS_EXCEPTION;
-    
+
     sp = JS_VALUE_GET_STRING(s);
     p = 0;
     if (p < sp->len && (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {
@@ -48826,7 +49352,7 @@
     JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);
     int i, j;
     JSBinaryOperatorDefEntry *ent;
-    
+
     if (opset) {
         for(i = 0; i < JS_OVOP_COUNT; i++) {
             if (opset->self_ops[i])
@@ -48858,7 +49384,7 @@
     JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);
     int i, j;
     JSBinaryOperatorDefEntry *ent;
-    
+
     if (opset) {
         for(i = 0; i < JS_OVOP_COUNT; i++) {
             if (opset->self_ops[i])
@@ -48958,7 +49484,7 @@
         }
         op_count = opset1->operator_counter;
         JS_FreeValue(ctx, prop);
-        
+
         /* we assume there are few entries */
         new_tab = js_realloc(ctx, def->tab,
                              (def->count + 1) * sizeof(def->tab[0]));
@@ -48969,7 +49495,7 @@
         ent = def->tab + def->count - 1;
         memset(ent, 0, sizeof(def->tab[0]));
         ent->operator_index = op_count;
-        
+
         for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
             prop = JS_GetPropertyStr(ctx, arg,
                                      js_overloadable_operator_names[i]);
@@ -49006,7 +49532,7 @@
     const JSOverloadableOperatorEnum ops[2] = { JS_OVOP_DIV, JS_OVOP_POW };
     JSOverloadableOperatorEnum op;
     int i;
-    
+
     opset_obj = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
                                JS_ATOM_Symbol_operatorSet);
     if (JS_IsException(opset_obj))
@@ -49136,7 +49662,7 @@
     case JS_TAG_BIG_FLOAT:
         {
             bf_t *a, a_s;
-            
+
             a = JS_ToBigFloat(ctx, &a_s, val);
             if (!bf_is_finite(a)) {
                 JS_FreeValue(ctx, val);
@@ -49251,7 +49777,7 @@
     bf_t a_s, b_s, *a, *b, *r, *q;
     int status;
     JSValue q_val, r_val;
-    
+
     q_val = JS_NewBigInt(ctx);
     if (JS_IsException(q_val))
         return JS_EXCEPTION;
@@ -49302,7 +49828,7 @@
     bf_t a_s, *a, *r, *rem;
     int status;
     JSValue r_val, rem_val;
-    
+
     r_val = JS_NewBigInt(ctx);
     if (JS_IsException(r_val))
         return JS_EXCEPTION;
@@ -49380,7 +49906,7 @@
     uint64_t bits;
     bf_t a_s, *a = &a_s, *r, mask_s, *mask = &mask_s;
     JSValue res;
-    
+
     if (JS_ToIndex(ctx, &bits, argv[0]))
         return JS_EXCEPTION;
     res = JS_NewBigInt(ctx);
@@ -49447,7 +49973,7 @@
     rt->bigint_ops.unary_arith = js_unary_arith_bigint;
     rt->bigint_ops.binary_arith = js_binary_arith_bigint;
     rt->bigint_ops.compare = js_compare_bigfloat;
-    
+
     ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);
     JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
                                js_bigint_proto_funcs,
@@ -49872,7 +50398,7 @@
 {
     JSValueConst val = argv[0];
     JSBigFloat *p;
-    
+
     if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)
         return JS_FALSE;
     p = JS_VALUE_GET_PTR(val);
@@ -49884,7 +50410,7 @@
 {
     JSValueConst val = argv[0];
     JSBigFloat *p;
-    
+
     if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)
         return JS_FALSE;
     p = JS_VALUE_GET_PTR(val);
@@ -50338,7 +50864,7 @@
 {
     JSRuntime *rt = ctx->rt;
     JSValueConst obj1;
-    
+
     rt->bigfloat_ops.to_string = js_bigfloat_to_string;
     rt->bigfloat_ops.from_string = js_string_to_bigfloat;
     rt->bigfloat_ops.unary_arith = js_unary_arith_bigfloat;
@@ -50346,7 +50872,7 @@
     rt->bigfloat_ops.compare = js_compare_bigfloat;
     rt->bigfloat_ops.mul_pow10_to_float64 = js_mul_pow10_to_float64;
     rt->bigfloat_ops.mul_pow10 = js_mul_pow10;
-    
+
     ctx->class_proto[JS_CLASS_BIG_FLOAT] = JS_NewObject(ctx);
     JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT],
                                js_bigfloat_proto_funcs,
@@ -50522,7 +51048,7 @@
     const char *str;
     size_t size;
     int rnd_mode;
-    
+
     str = JS_ToCStringLen(ctx, &size, obj);
     if (!str)
         return -1;
@@ -50562,7 +51088,7 @@
     int64_t val;
     BOOL has_prec;
     int rnd_mode;
-    
+
     if (!JS_IsObject(obj)) {
         JS_ThrowTypeErrorNotAnObject(ctx);
         return -1;
@@ -50575,7 +51101,7 @@
     if (rnd_mode < 0)
         return -1;
     fe->flags = rnd_mode;
-    
+
     prop = JS_GetProperty(ctx, obj, JS_ATOM_maximumSignificantDigits);
     if (JS_IsException(prop))
         return -1;
@@ -50630,7 +51156,7 @@
         op_count = 1;
     else
         op_count = 2;
-    
+
     op1 = JS_ToNumeric(ctx, argv[0]);
     if (JS_IsException(op1))
         return op1;
@@ -51428,9 +51954,35 @@
     return JS_EXCEPTION;
 }
 
+static JSValue js_array_buffer_compare(JSContext *ctx,
+  JSValueConst this_val,
+  int argc, JSValueConst *argv)
+{
+  if (argc == 0) {
+  TYPE_ERROR:
+    JS_ThrowTypeError(ctx, "ArrayBuffer expected");
+    return JS_EXCEPTION;
+  }
+
+  size_t sizet;
+  uint8_t *pt = JS_GetArrayBuffer(ctx, &sizet, this_val);
+  if (!pt) goto TYPE_ERROR;
+
+  size_t size;
+  uint8_t *p = JS_GetArrayBuffer(ctx, &size, argv[0]);
+  if (!p) goto TYPE_ERROR;
+
+  if (sizet < size) return JS_NewInt32(ctx, -1);
+  if (sizet > size) return JS_NewInt32(ctx, 1);
+
+  return JS_NewInt32(ctx, memcmp(pt, p, size));
+
+}
+
 static const JSCFunctionListEntry js_array_buffer_proto_funcs[] = {
     JS_CGETSET_MAGIC_DEF("byteLength", js_array_buffer_get_byteLength, NULL, JS_CLASS_ARRAY_BUFFER ),
     JS_CFUNC_MAGIC_DEF("slice", 2, js_array_buffer_slice, JS_CLASS_ARRAY_BUFFER ),
+    JS_CFUNC_DEF("compare", 1, js_array_buffer_compare),
     JS_PROP_STRING_DEF("[Symbol.toStringTag]", "ArrayBuffer", JS_PROP_CONFIGURABLE ),
 };
 
@@ -51587,7 +52139,7 @@
     }
     return JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));
 }
-                               
+
 static JSValue js_typed_array_get_toStringTag(JSContext *ctx,
                                               JSValueConst this_val)
 {
@@ -52007,7 +52559,7 @@
 
     if (typed_array_is_detached(ctx, p))
         return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
-    
+
     shift = typed_array_size_log2(p->class_id);
     switch(shift) {
     case 0:
@@ -52148,7 +52700,7 @@
             res = 0;
         goto done;
     }
-    
+
     is_bigint = 0;
     is_int = 0; /* avoid warning */
     v64 = 0; /* avoid warning */
@@ -52166,7 +52718,7 @@
 #ifdef CONFIG_BIGNUM
     if (tag == JS_TAG_BIG_INT) {
         JSBigFloat *p1 = JS_VALUE_GET_PTR(argv[0]);
-        
+
         if (p->class_id == JS_CLASS_BIG_INT64_ARRAY) {
             if (bf_get_int64(&v64, &p1->num, 0) != 0)
                 goto done;
@@ -52799,7 +53351,7 @@
             uint32_t *array_idx;
             void *array_tmp;
             size_t i, j;
-            
+
             /* XXX: a stable sort would use less memory */
             array_idx = js_malloc(ctx, len * sizeof(array_idx[0]));
             if (!array_idx)
@@ -53613,7 +54165,7 @@
    }
 
    switch(op | (size_log2 << 3)) {
-            
+
 #ifdef CONFIG_BIGNUM
 #define OP(op_name, func_name)                          \
     case ATOMICS_OP_ ## op_name | (0 << 3):             \
@@ -53662,7 +54214,7 @@
         a = atomic_load((_Atomic(uint64_t) *)ptr);
         break;
 #endif
-        
+
     case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3):
         {
             uint8_t v1 = v;
@@ -53837,7 +54389,7 @@
             return JS_EXCEPTION;
     } else
 #endif
-    {        
+    {
         if (JS_ToInt32(ctx, &v32, argv[2]))
             return JS_EXCEPTION;
         v = v32;
@@ -54059,3 +54611,295 @@
     JS_AddIntrinsicAtomics(ctx);
 #endif
 }
+
+#ifdef CONFIG_DEBUGGER
+
+void* js_debugger_get_object_id(JSValue val) {
+  JSObject *p = JS_VALUE_GET_OBJ(val);
+  return p;
+}
+
+JSValue js_debugger_local_variables(JSContext *ctx, int stack_index)
+{
+  JSValue ret = JS_NewObject(ctx);
+
+  // put exceptions on the top stack frame
+  if (stack_index == 0 && !JS_IsNull(ctx->rt->current_exception) && !JS_IsUndefined(ctx->rt->current_exception))
+    JS_SetPropertyStr(ctx, ret, "<exception>", JS_DupValue(ctx, ctx->rt->current_exception));
+
+  JSStackFrame *sf;
+  int cur_index = 0;
+
+  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
+    // this val is one frame up
+
+    if (cur_index < stack_index) {
+      cur_index++;
+      continue;
+    }
+
+    JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);
+    if (!f || !js_class_has_bytecode(f->class_id))
+      goto done;
+
+    if (JS_VALUE_GET_OBJ(*sf->pthis) != JS_VALUE_GET_OBJ(ctx->global_obj))
+      JS_SetPropertyStr(ctx, ret, "this", JS_DupValue(ctx, *sf->pthis));
+
+    JSFunctionBytecode *b = f->u.func.function_bytecode;
+
+    for (uint32_t i = 0; i < b->arg_count + b->var_count; i++) {
+      JSValue var_val;
+      if (i < b->arg_count)
+        var_val = sf->arg_buf[i];
+      else
+        var_val = sf->var_buf[i - b->arg_count];
+
+      if (JS_IsUninitialized(var_val))
+        continue;
+
+      JSVarDef *vd = b->vardefs + i;
+      JS_SetProperty(ctx, ret, vd->var_name, JS_DupValue(ctx, var_val));
+    }
+
+    break;
+  }
+
+done:
+  return ret;
+}
+
+JSValue js_debugger_closure_variables(JSContext *ctx, int stack_index) {
+  JSValue ret = JS_NewObject(ctx);
+
+  JSStackFrame *sf;
+  int cur_index = 0;
+  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
+    if (cur_index < stack_index) {
+      cur_index++;
+      continue;
+    }
+
+    JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);
+    if (!f || !js_class_has_bytecode(f->class_id))
+      goto done;
+
+    JSFunctionBytecode *b = f->u.func.function_bytecode;
+
+    for (uint32_t i = 0; i < b->closure_var_count; i++) {
+      JSClosureVar *cvar = b->closure_var + i;
+      JSValue var_val;
+      JSVarRef *var_ref = NULL;
+      if (f->u.func.var_refs)
+        var_ref = f->u.func.var_refs[i];
+      if (!var_ref || !var_ref->pvalue)
+        continue;
+      var_val = *var_ref->pvalue;
+
+      if (JS_IsUninitialized(var_val))
+        continue;
+
+      JS_SetProperty(ctx, ret, cvar->var_name, JS_DupValue(ctx, var_val));
+    }
+
+    break;
+  }
+
+done:
+  return ret;
+}
+
+JSValue js_debugger_build_backtrace(JSContext *ctx, const uint8_t *cur_pc)
+{
+  JSStackFrame *sf;
+  const char *func_name_str;
+  JSObject *p;
+  JSValue ret = JS_NewArray(ctx);
+  uint32_t stack_index = 0;
+
+  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
+    JSValue current_frame = JS_NewObject(ctx);
+
+    uint32_t id = stack_index++;
+    JS_SetPropertyStr(ctx, current_frame, "id", JS_NewUint32(ctx, id));
+
+    func_name_str = get_func_name(ctx, sf->cur_func);
+    if (!func_name_str || func_name_str[0] == '\0')
+      JS_SetPropertyStr(ctx, current_frame, "name", JS_NewString(ctx, "<anonymous>"));
+    else
+      JS_SetPropertyStr(ctx, current_frame, "name", JS_NewString(ctx, func_name_str));
+    JS_FreeCString(ctx, func_name_str);
+
+    p = JS_VALUE_GET_OBJ(sf->cur_func);
+    if (p && js_class_has_bytecode(p->class_id)) {
+      JSFunctionBytecode *b;
+      int line_num1;
+
+      b = p->u.func.function_bytecode;
+      if (b->has_debug) {
+        const uint8_t *pc = sf != ctx->rt->current_stack_frame || !cur_pc ? sf->cur_pc : cur_pc;
+        line_num1 = find_line_num(ctx, b, pc - b->byte_code_buf - 1);
+        JS_SetPropertyStr(ctx, current_frame, "filename", JS_AtomToString(ctx, b->debug.filename));
+        if (line_num1 != -1)
+          JS_SetPropertyStr(ctx, current_frame, "lineno", JS_NewUint32(ctx, line_num1));
+      }
+    }
+    else {
+      JS_SetPropertyStr(ctx, current_frame, "name", JS_NewString(ctx, "(native)"));
+    }
+    JS_SetPropertyUint32(ctx, ret, id, current_frame);
+  }
+  return ret;
+}
+
+uint32_t js_debugger_stack_depth(JSContext *ctx) {
+  uint32_t stack_index = 0;
+  JSStackFrame *sf = ctx->rt->current_stack_frame;
+  while (sf != NULL) {
+    sf = sf->prev_frame;
+    stack_index++;
+  }
+  return stack_index;
+}
+
+
+void JS_SetBreakpointHandler(JSContext *ctx, JSDebuggerCheckLineNoF* debugger_check_line_no)
+{
+  ctx->debugger_check_line_no = debugger_check_line_no;
+}
+
+void JS_SetDebuggerMode(JSContext *ctx, int onoff)
+{
+  ctx->debugger_enabled = onoff;
+}
+
+#endif // CONFIG_DEBUGGER
+
+#ifdef CONFIG_STORAGE
+
+/* get name of user's class. For this obj:
+
+     class Account {}
+     var obj = new Account();
+
+   it will return "Account" */
+
+JSValue JS_GetObjectClassName(JSContext *ctx, JSValueConst obj)
+{
+  JSValue ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);
+
+  JSObject *p;
+  if (JS_VALUE_GET_TAG(ctor) != JS_TAG_OBJECT)
+    goto fail;
+  p = JS_VALUE_GET_OBJ(ctor);
+  if (p->class_id != JS_CLASS_BYTECODE_FUNCTION)
+    goto fail;
+
+  JSValue name = JS_GetProperty(ctx, ctor, JS_ATOM_name);
+  JS_FreeValue(ctx, ctor);
+  return name;
+
+fail:
+  JS_FreeValue(ctx, ctor);
+  return JS_UNDEFINED;
+}
+
+/* get value defined in local call frames/namespaces */
+
+JSValue JS_GetLocalValue(JSContext *ctx, JSAtom name)
+{
+  for (JSStackFrame *sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
+
+    JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);
+    if (!f || !js_class_has_bytecode(f->class_id))
+      break;
+
+    JSFunctionBytecode *b = f->u.func.function_bytecode;
+
+    for (uint32_t i = 0; i < b->arg_count + b->var_count; i++) {
+      JSValue var_val;
+      if (i < b->arg_count)
+        var_val = sf->arg_buf[i];
+      else
+        var_val = sf->var_buf[i - b->arg_count];
+
+      if (JS_IsUninitialized(var_val))
+        continue;
+
+      JSVarDef *vd = b->vardefs + i;
+      if(name == vd->var_name)
+        return JS_DupValue(ctx, var_val);
+    }
+  }
+  return JS_UNDEFINED;
+}
+
+JS_BOOL js_is_persitable(JSValue val);
+
+JS_BOOL js_set_persistent_rt(JSRuntime* rt, JSValue val, struct JSStorage* pst, uint32_t oid, JS_PERSISTENT_STATUS status) {
+
+  assert(js_is_persitable(val));
+
+  JSObject* po = JS_VALUE_GET_OBJ(val);
+
+  if (status == JS_NOT_PERSISTENT) {
+    if (po->persistent) {
+      js_free_rt(rt,po->persistent);
+      po->persistent = NULL;
+    }
+    return 0;
+  }
+
+  if (!po->persistent) {
+    po->persistent = js_malloc_rt(rt, sizeof(struct JSPersitentBlock));
+    if (!po->persistent)
+      return 0;
+  }
+
+  po->persistent->status = status; // loaded, modified, etc.
+  po->persistent->oid = oid;
+  po->persistent->storage = pst;
+
+  return 1;
+}
+
+JS_BOOL js_set_persistent(JSContext* ctx, JSValue val, struct JSStorage* pst, uint32_t oid, JS_PERSISTENT_STATUS status) {
+  return js_set_persistent_rt(JS_GetRuntime(ctx), val, pst, oid, status);
+}
+
+void js_set_persistent_status(JSValue val, JS_PERSISTENT_STATUS status) {
+  assert(js_is_persitable(val));
+  JSObject* po = JS_VALUE_GET_OBJ(val);
+  assert(po->persistent);
+  assert(status);
+  po->persistent->status = status;
+}
+
+JS_PERSISTENT_STATUS js_is_persistent(JSValue val, struct JSStorage** pstor, uint32_t* poid)
+{
+  if(!js_is_persitable(val))
+    return JS_NOT_PERSISTENT;
+
+  JSObject* po = JS_VALUE_GET_OBJ(val);
+
+  if (!po->persistent)
+    return JS_NOT_PERSISTENT;
+
+  if (poid)
+    *poid = po->persistent->oid;
+  if (pstor)
+    *pstor = po->persistent->storage;
+
+  return po->persistent->status;
+}
+
+uint32_t* js_get_persistent_oid_ref(JSValue val)
+{
+  assert(js_is_persitable(val));
+
+  JSObject* po = JS_VALUE_GET_OBJ(val);
+  assert(po->persistent);
+
+  return &po->persistent->oid;
+}
+
+#endif
